# Define the scope of variables

* O escopo é o que determina em que pontos do código uma variável pode ser usada.

## Variáveis locais
* o ciclo de vida de uma variável local vai do ponto onde ela foi declarada até o fim do bloco onde ela foi declarada.
* declaradas dentro de métodos ou construtores.

Mas o que é um bloco? Podemos entender como bloco um trecho de código entre chaves. Pode ser um método, um construtor, o corpo de um if, de um for etc.:


public void m1() { // início do bloco do método
    int x = 10; // variável local do método

    if (x >= 10) { // início do bloco do if
        int y = 50; // variável local do if
        System.out.print(y);

    } // fim do bloco do if

} // fim do bloco do método
Analisando esse código, temos uma variável x, que é declarada no começo do método. Ela pode ser utilizada durante todo o corpo do método. Dentro do if, declaramos a variável y. y só pode ser utilizada dentro do corpo do if, delimitado pelas chaves. Se tentarmos usar y fora do corpo do if, teremos um erro de compilação, pois a variável saiu do seu escopo.

Tome cuidado especial com loops for. As variáveis declaradas na área de inicialização do loop só podem ser usadas no corpo do loop:


for (int i = 0, j = 0; i < 10; i++)
    j++;

System.out.println(j); // erro, já não está mais no escopo
Parâmetros de métodos também podem ser considerados variáveis locais ao método, ou seja, só podem ser usados dentro do método onde foram declarados:


    class Teste {

        public void m1(String bla) {
            System.out.print(bla);
        }

        public void m2() {
            // erro de compilação pois bla não existe neste
            // escopo
            System.out.println(bla);
        }
    }
Variáveis de instância
Variáveis de instância ou variáveis de objeto são os atributos dos objetos. São declaradas dentro da classe, mas fora de qualquer método ou construtor. Podem ser acessadas por qualquer membro da classe e ficam em escopo enquanto o objeto existir:


class Pessoa {
    // variável de instância ou variável de objeto
    String nome;

    public void setNome(String n) {
        // acessando a variável de instância no método
        this.nome = n;
    }
}
Variáveis estáticas (class variables)
Podemos declarar variáveis que são compartilhadas por todas as instâncias de uma classe usando a palavra chave static. Essas variáveis estão no escopo da classe, e lá ficarão enquanto a classe estiver carregada na memória (enquanto o programa estiver rodando, na grande maioria dos casos).


class Pessoa {
    static int id = 1;
}

class Teste {
    public static void main(String[] args) {
        Pessoa p = new Pessoa();
        System.out.println(p.id); // acessando pelo objeto
        System.out.println(Pessoa.id); // acessando direto pela
                                       // classe
    }
}
No caso de variáveis static, não precisamos ter uma referência para usá-las e podemos acessá-las diretamente a partir da classe, desde que respeitando as regras de visibilidade da variável.

Variáveis com o mesmo nome
Logicamente, não é possível declarar duas variáveis no mesmo escopo com o mesmo nome:


public void bla() {
    int a = 0;
    int a = 10;// erro
}
Mas, eventualmente, podemos ter variáveis em escopos diferentes que podem ser declaradas com o mesmo nome. Em casos em que possa haver ambiguidade na hora de declará-las, o próprio compilador irá emitir um erro evitando a confusão. Por exemplo, não podemos declarar variáveis de classe e de instância com o mesmo nome:


class Bla {
    static int a;
    int a; // erro de compilação,
}
...

System.out.println(new Bla().a); // qual variável estamos
                                 // acessando?
Também não podemos declarar variáveis locais com o mesmo nome de parâmetros:


public void metodo(String par) {
    int par = 0; // erro de compilação

    System.out.println(par); // qual?
}
Apesar de parecer estranho, é permitido declarar variáveis locais ou parâmetros com o mesmo nome de variáveis de instância ou de classe. Essa técnica é chamada de ::shadowing::. Nesses casos, é possível resolver a ambiguidade: para variáveis de classe, podemos referenciar pela própria classe; para variáveis de instância, usamos a palavra chave this:


class Pessoa {

    static int x = 0;
    int y = 0;

    public static void setX(int x) {
        // Usando a referência da classe
        Pessoa.x = x;
    }

    public void setY(int y) {
        // usando o this
        this.y = y;
    }
}
Quando não usamos o this ou o nome da classe para usar a variável, o compilador sempre utilizará a variável de menor escopo:


class X {
    int a = 10;

    public void metodo() {
        int a = 20; // shadowing
        System.out.println(a); // imprime 20
    }
}

#Define the structure of a Java class
PRÓXIMA ATIVIDADE

Nesta seção, iremos entender a estrutura de um arquivo java, onde inserir as declarações de pacotes e imports e como declarar classes e interfaces.

Para entender a estrutura de uma classe, vamos ver o arquivo Pessoa.java:


// Declaração de pacote
package br.com.caelum.certificacao;

// imports
import java.util.Date;

// Declaração da classe
class Pessoa {
    // conteúdo da classe
}
Pacotes
Pacotes servem para separar e organizar as diversas classes que temos em nossos sistemas. Todas as classes pertencem a um pacote, sendo que, caso o pacote não seja explicitamente declarado, a classe fará parte do que chamamos de pacote padrão, ou default package. Todas as classes no default package se enxergam e podem ser utilizadas entre si. Classes no pacote default não podem ser importadas para uso em outros pacotes:


// Uma classe no pacote padrão
class Pessoa {
    //...
}
Para definir qual o pacote a que a classe pertence, usamos a palavra-chave package, seguida do nome do pacote. Só pode existir um único package definido por arquivo, e ele deve ser a primeira instrução do arquivo. Após a definição do package, devemos finalizar a instrução com um ;. Podem existir comentários antes da definição de um pacote:


// declaração do pacote
package br.com.caelum.certificacao;

class Pessoa {
    //...
}
Aproveitando que tocamos no assunto, o package deve ser a primeira instrução de código que temos declarada em nosso arquivo. Comentários não são considerados parte do código, portanto, podem existir em qualquer lugar do arquivo java sem restrições.

Para inserir comentário em nosso código, temos as seguintes formas:


// comentário de linha

/*
   comentário de
   multiplas linhas
 */
class /* comentário no meio da linha */ Pessoa {

    /**
     *  JavaDoc, repare que a primeira linha do comentário tem
     *  2 asteriscos
     */
    public void metodo() {
    }
}
Para saber mais: JavaDoc
Classe
Uma classe é a forma no Java onde definimos os atributos e comportamentos de um objeto. A declaração de uma classe pode ser bem simples, apenas a palavra class seguida do nome e de {}:


class Pessoa {}
Existem outros modificadores que podem ser usados na definição de uma classe, mas veremos essas outras opções mais à frente, onde discutiremos esses modificadores com mais detalhes.

Vale lembrar que java é case sensitive e Class é o nome de uma classe e não podemos usá-lo para definir uma nova classe.

Dentro de uma classe, podemos ter variáveis, métodos e construtores. Essas estruturas são chamadas de membros da classe.:



class Pessoa {

    String nome;
    String sobrenome;

    Pessoa(String nome, String sobrenome) {
        this.nome = nome;
        this.sobrenome = sobrenome;
    }

    public String getNomeCompleto() {
        return this.nome + this.sobrenome;
    }
}
Nomes dos membros
Variaveis
Usando como exemplo a classe Pessoa definida anteriormente, nome e sobrenome são variáveis. A declaração de variáveis é bem simples, sempre o tipo seguido do nome da variável.

Dizemos que essas são variáveis de instância, pois existe uma cópia delas para cada objeto Pessoa criado em nosso programa. Cada cópia guarda o estado de uma certa instância desses objetos.

Existem ainda variáveis que não guardam valores ou referências para uma determinada instância, mas sim um valor compartilhado por todas as instâncias de objetos. Essas são variáveis estáticas, definidas com a palavra-chave static. Veremos mais sobre esse tipo de membro mais à frente.

Métodos
A declaração de métodos é um pouquinho diferente pois precisamos do tipo do retorno, seguido do nome do método e seguido de parênteses, sendo que pode ou não haver parâmetros de entrada desse método. Cada parâmetro é uma declaração de variável em si. Essa linha do método, onde está definido o retorno, o nome e os parâmetros é onde temos a assinatura do método. Cuidado, pois a assinatura de um método inclui somente o nome do método e os tipos dos parâmetros.

Assim como variáveis, métodos também podem ser static, como veremos mais adiante.

Construtores
Uma classe pode possuir zero ou vários construtores. Nossa classe Pessoa possui um construtor que recebe como parâmetros o nome e o sobrenome da pessoa. A principal diferença entre a declaração de um método e um construtor é que um construtor não tem retorno e possui o mesmo nome da classe.

Métodos com o mesmo nome da classe
Note que um construtor pode ter um return vazio:


class X {
    int j = -100;

    X(int i) {
        if (i > 1)
            return;
        j = i;
    }
}
Caso o valor seja maior que 1, o valor de j será -100, caso contrário, será o mesmo valor de i.

Interfaces
Além de classes, também podemos declarar interfaces em nossos arquivos java. Para definir uma interface usamos a palavra reservada interface:


interface Autenticavel {

    final int TAMANHO_SENHA = 8;

    void autentica(String login, String senha);
}
Em uma interface, devemos apenas definir a assinatura do método, sem a sua implementação. Além da assinatura de métodos, também é possível declarar constantes em interfaces.

Multíplas estruturas em um arquivo
Em java, é possível definir mais de uma classe/interface em um mesmo arquivo java, embora devamos seguir algumas regras:

Podem ser definidos em qualquer ordem;
Se existir alguma classe/interface pública, o nome do arquivo deve ser o mesmo dessa classe/interface;
Só pode existir uma classe/interface pública por arquivo;
Se não houver nenhuma classe/interface pública, o arquivo pode ter qualquer nome.
Logo, são válidos:


// arquivo1.java
interface Bar {}

class Foo {}

// Foo.java
public class Foo {}

interface X {}
Pacotes e imports em arquivos com múltiplas estruturas
As regras de pacotes e imports valem também para arquivos com múltiplas estruturas definidas. Caso exista a definição de um pacote, ela vale para todas as classes/interfaces definidas nesse arquivo, e o mesmo vale para imports.

#Create executable Java applications with a main method; run a Java program from the command line; produce console output

Nesta seção, entenderemos as diferenças entre classes normais e classes que podem ser executadas pela linha de comando.

Uma classe executável é uma classe que possui um método inicial para a execução do programa - o método main, que será chamado pela JVM. Classes sem o método main não são classes executáveis e não podem ser usadas como ponto inicial da aplicação.

Método main
O tal método de entrada deve seguir algumas regras para ser executado pela JVM:

Ser público (public);
Ser estático (static);
Não ter retorno (void);
Ter o nome main;
Receber como parâmetro um array ou varargs de String (String[] ou String...).
São então métodos main válidos os seguintes exemplos:


//Parâmetro como array
public static void main (String[] args) {}

//Parâmetro como varargs
public static void main (String... args) {}

//A ordem dos modificadores não importa
static public void main(String[] args) {}

//O nome do parâmetro não importa
public static void main (String... argumentos){}

//Também é uma definição válida de array
public static void main (String args[]) {}
Executando uma classe pela linha de comando
Para executar uma classe com main pela linha de comando, devemos compilar o arquivo com o comando javac e executar a classe com o comando java:

Usando o arquivo HelloWorld.java a seguir:


public class HelloWorld {

    public static void main(String[] args) {
        System.out.println("Hello World! ");
    }
}
Compilamos e executamos no terminal com os seguintes comandos:


$ javac HelloWorld.java
$
$ java HelloWorld
Hello World!
Repare que, para compilar a classe, passamos como parâmetro para o comando javac o nome do arquivo, enquanto para executar, passamos apenas o nome da classe (HelloWorld) para o comando java.

Passando parâmetros pela linha de comando
Ao executarmos uma classe pela linha de comando, podemos passar parâmetros para o método main. Esses valores serão recebidos no array do método main. Por exemplo, vamos passar um nome para a classe HelloWorld:


public class HelloWorld{

    public static void main(String[] args) {
        //Lendo o valor da primeira posição do array args
        System.out.println("Hello " + args[0] + "!");
    }
}
Para informar o valor do parâmetro, é só informá-lo APÓS o nome da classe que está sendo executada:


java HelloWorld Mario
Hello Mario!
Você pode passar quantos parâmetros quiser, basta separá-los por espaço. Cada parâmetro informado será armazenado em uma posição do array, na mesma ordem em que foi informado.

Compilação e execução
Para criar um programa java, é preciso escrever um código-fonte e, através de um compilador, gerar o executável (bytecode). O compilador do JDK (Java Development Kit) é o javac. Para a prova de certificação, devemos conhecer o comportamento desse compilador.

A execução do bytecode é feita pela JVM (Java Virtual Machine). O comando java invoca a máquina virtual para executar um programa java. Ao baixarmos o Java, podemos escolher baixar o JDK, que já vem com o JRE, ou somente o JRE (Java Runtime Environment), que inclui a Virtual Machine.

Algumas questões da prova abordam aspectos fundamentais do processo de compilação e de execução. É necessário saber como os comandos javac e o java procuram os arquivos.

javac
Imagine o arquivo Prova.java dentro do diretório de meu projeto:


class Prova {
    double tempo;
}

$ javac Prova.java
O bytecode da classe Prova gerado na compilação é colocado no arquivo Prova.class dentro do nosso diretório de trabalho, no meu caso, projeto. O resultado é:



Os projetos profissionais utilizam o recurso de pacotes para melhor organizar os fontes e os bytecodes. Vejamos qual é o comportamento do javac com a utilização de pacotes. Colocamos o arquivo Prova.java no diretório certificacao:


package certificacao;
class Prova {
    double tempo;
}

[certificacao]$ javac certificacao/Prova.java
Nesse exemplo, o arquivo Prova.class é colocado no diretório certificacao.



Escolhendo a versão do Java na hora de compilar
Na hora da compilação, é possível definir em que versão do Java o código-fonte foi escrito. Isso é feito com a opção -source do comando javac. (javac MinhaClasse.java -source 1.3).

java
Vamos utilizar um exemplo para mostrar o funcionamento do comando java, criando o arquivo Teste.java no mesmo diretório, no mesmo pacote:


package certificacao;
class Teste {
    public static void main(String[] args) {
        Prova p = new Prova();
        p.tempo = 210;
        System.out.println(p.tempo);
    }
}

$ javac certificacao/Teste.java
$ java certificacao.Teste
Saída:


210.0
E o resultado são os arquivos:



Somente o arquivo Teste.java foi passado para o compilador. Nesse arquivo, a classe Teste utiliza a classe Prova que se encontra em outro arquivo, Prova.java. Dessa forma, o compilador vai compilar automaticamente o arquivo Prova.java se necessário.

Para executar, é preciso passar o nome completo da classe desejada para a máquina virtual. O sufixo .class não faz parte do nome da classe, então ele não aparece na invocação da máquina virtual pelo comando java.

Propriedades na linha de comando
A prova ainda cobra conhecimentos sobre como executar um programa java passando parâmetros ou propriedades para a JVM e essas propriedades são identificadas pelo -D antes delas. Este -D não faz parte da chave.


java -Dchave1=abc -Dchave2=def Foo xpto bar
chave1=abc e chave2=def são parâmetros/propriedades e xpto e bar são argumentos recebidos pelo método main.

Classpath
Para compilar ou para executar, é necessário que os comandos javac e java possam encontrar as classes referenciadas pela aplicação java.

A prova de certificação exige o conhecimento do algoritmo de busca das classes. As classes feitas pelo programador são encontradas através do classpath (caminho das classes).

O classpath é formado por diretórios, jars e zips que contenham as classes e pacotes da nossa aplicação. Por padrão, o classpath está configurado para o diretório corrente (.).

Configurando o classpath
Há duas maneiras de configurar o classpath:

1) Configurando a variável de ambiente CLASSPATH no sistema operacional.

Basta seguir as opções do SO em questão e definir a variável. Isso é considerado uma má prática no dia a dia porque é um classpath global, que vai valer para qualquer programa java executado na máquina.

2) Com as opções -cp ou -classpath dos comandos javac ou java.

É a forma mais usada. Imagine que queremos usar alguma biblioteca junto com nosso programa:


$ javac -cp /diretorio/biblioteca.jar Prova.java
$ java -cp /diretorio/biblioteca.jar Prova
E podemos passar tanto caminhos de outras pastas como de JARs ou zips. Para passar mais de uma coisa no classpath, usamos o separador de parâmetros no SO (no Windows é ponto e vírgula, no Linux/Mac/Solaris/Unix são dois pontos):


$ javac -cp /diretorio/biblioteca.jar;/outrodir/ scjp/Prova.java
$ java -cp /diretorio/biblioteca.jar;/outrodir/ scjp.Prova
Para saber mais: arquivos JAR
Para facilitar a distribuição de bibliotecas de classes ou de aplicativos, o JDK disponibiliza uma ferramenta para a compactação das classes java.

Um arquivo JAR nada mais é que a pasta de nossas classes no formato ZIP mas com extensão .jar.

Para criar um jar incluindo a pasta scjp que fizemos antes:

jar -cf bib.jar scjp
Agora podemos executar nossa classe usando esse jar:

java -cp bib.jar scjp.Prova
Para saber mais: META-INF/Manifest.mf
Ao criar o jar usando o comando jar do JDK, ele cria automaticamente a pasta META-INF, que é usada para configurações relativas ao nosso jar. E dentro dela, cria o arquivo Manifest.mf.

Esse arquivo pode ser usado para algumas configurações. Por exemplo, é possível dizer qual classe do nosso jar é a classe principal (Main-Class) e que deve ser executada.

Basta criar um arquivo chamado Manifest.mf com a seguinte instrução indicando a classe com o método main:

Main-Class: scjp.Teste
E depois gerar o jar passando esse arquivo:

jar -cmf bib.jar meumanifest scjp
Na hora de rodar um jar com Main-Class, basta usar:

java -jar bib.jar
TIRAR DÚVIDA

#Create executable Java applications with a main method; run a Java program from the command line; produce console output
Nesta seção, entenderemos as diferenças entre classes normais e classes que podem ser executadas pela linha de comando.

Uma classe executável é uma classe que possui um método inicial para a execução do programa - o método main, que será chamado pela JVM. Classes sem o método main não são classes executáveis e não podem ser usadas como ponto inicial da aplicação.

Método main
O tal método de entrada deve seguir algumas regras para ser executado pela JVM:

Ser público (public);
Ser estático (static);
Não ter retorno (void);
Ter o nome main;
Receber como parâmetro um array ou varargs de String (String[] ou String...).
São então métodos main válidos os seguintes exemplos:


//Parâmetro como array
public static void main (String[] args) {}

//Parâmetro como varargs
public static void main (String... args) {}

//A ordem dos modificadores não importa
static public void main(String[] args) {}

//O nome do parâmetro não importa
public static void main (String... argumentos){}

//Também é uma definição válida de array
public static void main (String args[]) {}
Executando uma classe pela linha de comando
Para executar uma classe com main pela linha de comando, devemos compilar o arquivo com o comando javac e executar a classe com o comando java:

Usando o arquivo HelloWorld.java a seguir:


public class HelloWorld {

    public static void main(String[] args) {
        System.out.println("Hello World! ");
    }
}
Compilamos e executamos no terminal com os seguintes comandos:


$ javac HelloWorld.java
$
$ java HelloWorld
Hello World!
Repare que, para compilar a classe, passamos como parâmetro para o comando javac o nome do arquivo, enquanto para executar, passamos apenas o nome da classe (HelloWorld) para o comando java.

Passando parâmetros pela linha de comando
Ao executarmos uma classe pela linha de comando, podemos passar parâmetros para o método main. Esses valores serão recebidos no array do método main. Por exemplo, vamos passar um nome para a classe HelloWorld:


public class HelloWorld{

    public static void main(String[] args) {
        //Lendo o valor da primeira posição do array args
        System.out.println("Hello " + args[0] + "!");
    }
}
Para informar o valor do parâmetro, é só informá-lo APÓS o nome da classe que está sendo executada:


java HelloWorld Mario
Hello Mario!
Você pode passar quantos parâmetros quiser, basta separá-los por espaço. Cada parâmetro informado será armazenado em uma posição do array, na mesma ordem em que foi informado.

Compilação e execução
Para criar um programa java, é preciso escrever um código-fonte e, através de um compilador, gerar o executável (bytecode). O compilador do JDK (Java Development Kit) é o javac. Para a prova de certificação, devemos conhecer o comportamento desse compilador.

A execução do bytecode é feita pela JVM (Java Virtual Machine). O comando java invoca a máquina virtual para executar um programa java. Ao baixarmos o Java, podemos escolher baixar o JDK, que já vem com o JRE, ou somente o JRE (Java Runtime Environment), que inclui a Virtual Machine.

Algumas questões da prova abordam aspectos fundamentais do processo de compilação e de execução. É necessário saber como os comandos javac e o java procuram os arquivos.

javac
Imagine o arquivo Prova.java dentro do diretório de meu projeto:


class Prova {
    double tempo;
}

$ javac Prova.java
O bytecode da classe Prova gerado na compilação é colocado no arquivo Prova.class dentro do nosso diretório de trabalho, no meu caso, projeto. O resultado é:



Os projetos profissionais utilizam o recurso de pacotes para melhor organizar os fontes e os bytecodes. Vejamos qual é o comportamento do javac com a utilização de pacotes. Colocamos o arquivo Prova.java no diretório certificacao:


package certificacao;
class Prova {
    double tempo;
}

[certificacao]$ javac certificacao/Prova.java
Nesse exemplo, o arquivo Prova.class é colocado no diretório certificacao.



Escolhendo a versão do Java na hora de compilar
Na hora da compilação, é possível definir em que versão do Java o código-fonte foi escrito. Isso é feito com a opção -source do comando javac. (javac MinhaClasse.java -source 1.3).

java
Vamos utilizar um exemplo para mostrar o funcionamento do comando java, criando o arquivo Teste.java no mesmo diretório, no mesmo pacote:


package certificacao;
class Teste {
    public static void main(String[] args) {
        Prova p = new Prova();
        p.tempo = 210;
        System.out.println(p.tempo);
    }
}

$ javac certificacao/Teste.java
$ java certificacao.Teste
Saída:


210.0
E o resultado são os arquivos:



Somente o arquivo Teste.java foi passado para o compilador. Nesse arquivo, a classe Teste utiliza a classe Prova que se encontra em outro arquivo, Prova.java. Dessa forma, o compilador vai compilar automaticamente o arquivo Prova.java se necessário.

Para executar, é preciso passar o nome completo da classe desejada para a máquina virtual. O sufixo .class não faz parte do nome da classe, então ele não aparece na invocação da máquina virtual pelo comando java.

Propriedades na linha de comando
A prova ainda cobra conhecimentos sobre como executar um programa java passando parâmetros ou propriedades para a JVM e essas propriedades são identificadas pelo -D antes delas. Este -D não faz parte da chave.


java -Dchave1=abc -Dchave2=def Foo xpto bar
chave1=abc e chave2=def são parâmetros/propriedades e xpto e bar são argumentos recebidos pelo método main.

Classpath
Para compilar ou para executar, é necessário que os comandos javac e java possam encontrar as classes referenciadas pela aplicação java.

A prova de certificação exige o conhecimento do algoritmo de busca das classes. As classes feitas pelo programador são encontradas através do classpath (caminho das classes).

O classpath é formado por diretórios, jars e zips que contenham as classes e pacotes da nossa aplicação. Por padrão, o classpath está configurado para o diretório corrente (.).

Configurando o classpath
Há duas maneiras de configurar o classpath:

1) Configurando a variável de ambiente CLASSPATH no sistema operacional.

Basta seguir as opções do SO em questão e definir a variável. Isso é considerado uma má prática no dia a dia porque é um classpath global, que vai valer para qualquer programa java executado na máquina.

2) Com as opções -cp ou -classpath dos comandos javac ou java.

É a forma mais usada. Imagine que queremos usar alguma biblioteca junto com nosso programa:


$ javac -cp /diretorio/biblioteca.jar Prova.java
$ java -cp /diretorio/biblioteca.jar Prova
E podemos passar tanto caminhos de outras pastas como de JARs ou zips. Para passar mais de uma coisa no classpath, usamos o separador de parâmetros no SO (no Windows é ponto e vírgula, no Linux/Mac/Solaris/Unix são dois pontos):


$ javac -cp /diretorio/biblioteca.jar;/outrodir/ scjp/Prova.java
$ java -cp /diretorio/biblioteca.jar;/outrodir/ scjp.Prova
Para saber mais: arquivos JAR
Para facilitar a distribuição de bibliotecas de classes ou de aplicativos, o JDK disponibiliza uma ferramenta para a compactação das classes java.

Um arquivo JAR nada mais é que a pasta de nossas classes no formato ZIP mas com extensão .jar.

Para criar um jar incluindo a pasta scjp que fizemos antes:

jar -cf bib.jar scjp
Agora podemos executar nossa classe usando esse jar:

java -cp bib.jar scjp.Prova
Para saber mais: META-INF/Manifest.mf
Ao criar o jar usando o comando jar do JDK, ele cria automaticamente a pasta META-INF, que é usada para configurações relativas ao nosso jar. E dentro dela, cria o arquivo Manifest.mf.

Esse arquivo pode ser usado para algumas configurações. Por exemplo, é possível dizer qual classe do nosso jar é a classe principal (Main-Class) e que deve ser executada.

Basta criar um arquivo chamado Manifest.mf com a seguinte instrução indicando a classe com o método main:

Main-Class: scjp.Teste
E depois gerar o jar passando esse arquivo:

jar -cmf bib.jar meumanifest scjp
Na hora de rodar um jar com Main-Class, basta usar:

java -jar bib.jar
TIRAR DÚVIDA

#Import other Java packages to make them accessible in your code
 Importe outros pacotes Java e deixe-os acessíveis ao seu código
PRÓXIMA ATIVIDADE

Se duas classes estão no mesmo pacote, elas se "enxergam" entre si, sem a necessidade de colocar o nome do pacote. Por exemplo, imagine que as classes Pessoa e Endereco estejam no mesmo pacote:


package modelo;

class Endereco {
    String rua;
    String numero;
    String bairro;
    //...
}
E o outro arquivo:


package modelo;

class Pessoa {
    Endereco endereco; // Pessoa usando o endereço
}
Para usar uma classe que está em outro pacote, temos duas opções: podemos referenciá-la usando o que chamamos de Fully Qualified Name, ou seja, o nome do pacote seguido do nome da classe. O código ficaria assim:


package financeiro;

class Pedido {
    modelo.Pessoa cliente; // Usando a classe Pessoa de outro
                           // pacote
}
Tentamos compilar mas ele não deixa, porque uma classe, por padrão, só pode ser acessada dentro do próprio pacote, e a nossa classe Pessoa está no pacote modelo. Portanto, definiremos nossa classe Pessoa como pública. Veremos com mais calma os modificadores de acesso na seção que cobra isso na prova. Por enquanto, basta lembrar que classes públicas podem ser acessadas por outros pacotes, já classes padrão não podem.


package modelo;

public class Pessoa {
    Endereco endereco // Pessoa usando o endereço
}
Outra opção é importar a classe Produto e referenciá-la apenas pelo nome simples dentro de nosso código. Para fazer o import usamos a palavra import, seguida do Fully Qualified Name da classe. A instrução de import deve aparecer na classe logo após o package (se este existir), e antes da definição da classe. É possível importar mais de uma classe por vez:


package modelo;

// Importando a classe Produto do pacote estoque
import estoque.Produto;
// Outro import qualquer
import java.util.Date;

class Pedido {
    Pessoa cliente; // mesmo pacote
    Produto item; // importado
    Date dataEmissao; //importado
}
Também é possível importar todas as classes de um determinado pacote, basta usar um * após o nome do pacote:


// Importando todas as classes do pacote estoque
import estoque.*;
Importando classes com mesmo nome
Quando precisamos usar duas classes com o mesmo nome mas de pacotes diferentes, só podemos importar uma delas. A outra deve ser referenciada pelo Fully Qualified Name. Tentativas de importar as duas classes irão resultar em erros de compilação:


import java.util.Date;
import java.sql.Date; // Erro de compilação pois temos duas
                      // classes Date

class Teste {
    Date d1;
    Date d2;
}
O correto seria:


import java.util.Date;

class Teste {
    Date d1;            // java.util
    java.sql.Date d2; // java.sql
}
Caso tenhamos um import específico e um import genérico, o Java usa o específico:


import java.util.*;
import java.sql.Date;

class Teste{
    Date d1; // java.sql
    Date d2; // java.sql
}
Por padrão, todas as classes do pacote java.lang são importadas. Um ponto importante é que nenhuma classe de pacote que não seja o padrão pode importar uma classe do pacote padrão:


class Gerente {
}

package modelo;
classe Banco {
    Gerente gerente; // não compila pois não é possível importar
                     // tipos do pacote padrão de jeito *nenhum*
}
Pacotes
Nesta seção, entenderemos mais a fundo como funciona a declaração de pacotes, e como isso influencia nos imports das classes.

Como já discutimos anteriormente, pacotes servem para organizar suas classes e interfaces. Eles permitem agrupar componentes que tenham alguma relação entre si, além de garantir algum nível de controle de acesso a membros. Além de serem uma divisão lógica para as suas classes, os pacotes também definem uma separação física entre os arquivos de seu projeto, já que espelham a estrutura de diretórios dos arquivos do projeto.

Subpacotes e estrutura de diretórios
Pacotes são usados pela JVM como uma maneira de encontrar as classes no sistema de arquivos, logo a estrutura de diretórios do projeto deve ser a mesma da estrutura de pacotes. Vamos usar como exemplo a classe Pessoa:


package projeto.modelo;

public class Pessoa {}
O arquivo Pessoa.java deve estar localizado dentro do diretório modelo, que deve estar dentro do diretorio projeto, conforme a figura a seguir:



Dizemos que modelo é um subpacote de projeto, já que está dentro dele. Podemos ter vários subpacotes, como projeto.utils e projeto.conversores, por exemplo. Usamos o caractere . como separador de pacotes e subpacotes.

Convenções de nomes para pacotes
Existem algumas convenções para nomes de pacotes. Elas não são obrigatórias, mas geralmente são seguidas para facilitar o entendimento e organização do código:

O nome do pacote deve ser todo em letras minúsculas;
Um pacote deve começar com o site da empresa, ao contrário;
Após o site, deve vir o projeto;
Após o projeto, a estrutura é livre.
Import usando classes de outros pacotes
Existem diversas maneiras de referenciar uma classe de pacote diferente em nosso código. Vamos analisar essas opções:

Fully Qualified Name
Podemos referenciar uma classe em nosso código usando o que chamamos de Fully Qualified Name, ou FQN. Ele é composto pelo pacote completo mais o nome da classe, por exemplo:


class Pessoa {
    // FQN da classe Calendar
    java.util.Calendar dataDeNascimento;
}
import
Usar o FQN nem sempre deixa o código legível, portanto, em vez de usar o nome completo da classe, podemos importá-la e usar apenas o nome simples da classe:


import java.util.Calendar;

class Pessoa {
    Calendar dataDeNascimento;
}
É permitido também importar todas as classes de um pacote de uma vez, usando o * no lugar do nome da classe:


import java.util.*;

class Pessoa {
    // Calendar e List são do pacote java.util
    Calendar dataDeNascimento;
    List<String> apelidos;
}
Caso existam duas classes com o mesmo nome, mas de pacotes diferentes, só podemos importar uma delas. A outra deve ser referenciada pelo FQN:


import java.util.Date;

class Foo {
    //do java.util
    Date some;
    java.sql.Date other;
}
]

Multiplos imports com *
Caso importemos dois ou mais pacotes que contenham classes com o mesmo nome, será obrigatório especificar, usando o FQN, qual das classes queremos utilizar. Ao tentar usar apenas o nome simples da classe, teremos um erro de compilação:


import java.util.*;
import java.sql.*;

public class Testes {
    private Date d; // Erro de compilação, de qual pacote é
                    // para usar?
}
Import de subpacotes
Em Java, não podemos importar todas as classes de subpacotes usando *. Veja a seguinte situação, considerando que cada classe foi definida em seu próprio arquivo:


package sistema.prova;

public class Pergunta {}

package sistema.banco;

public class PerguntaDao {}

package sistema;

public class Exame {}

package sistema.teste;

import sistema.*; //só importou a classe Exame

public class Teste {}
O único modo de importar todas as classes é explicitamente importando cada subpacote:


package sistema.teste;

import sistema.*;
import sistema.prova.*;
import sistema.banco.*;
public class Teste {}
import static
Desde o Java 5, é possível importar apenas métodos e atributos estáticos de uma classe, usando a palavra-chave static juntamente com o import. Podemos importar um a um ou simplesmente importar todos usando *:


package model;

public class Utils {

    // Atributo estático público
    public static int VALOR = 0;
    // Métodos estáticos públicos
    public static void metodo1() {}
    public static void metodo1(int a) {}

}

// Importando todos os membros public static de Utils
import static model.Utils.*;

public class Testes {

    public static void main(String[] args) {
        int x = VALOR;
        metodo1();
        metodo1(x);
    }
}
TIRAR DÚVIDA


#Compare and contrast the features and components of Java such as: platform independence, object orientation, encapsulation, etc.
Plataforma Java : independência de plataforma, OO e encapsulamento.
PRÓXIMA ATIVIDADE

Compare e contraste as funcionalidades e componentes da plataforma Java como: independência de plataforma, orientação a objeto, encapsulamento etc.
linguagem X plataforma
Quando pensamos na palavra Java geralmente pensamos na linguagem, mas na verdade o Java é muito mais que isso. É toda uma plataforma de desenvolvimento, com características bem distintas que permitiram sua adoção em massa por empresas e desenvolvedores.

Quando escrevemos um programa na linguagem Java, para conseguirmos executá-lo, é necessário compilar o código. Uma das diferenças do Java para outras linguagens mais tradicionais é que o resultado da compilação não é exatamente código de máquina, que será interpretado pelo sistema operacional do computador.

O código Java compilado é chamado de bytecode. É um arquivo binário que possui a extensão .class.

Esse arquivo será lido e interpretado pela máquina virtual java, ou simplesmente JVM. A JVM é como um computador genérico. Seu papel é interpretar as instruções do bytecode e converter estas instruções para código de máquina, para ser executado pelo sistema operacional nativo do computador.

Existem implementações de JVM para os principais sistemas operacionais, além de diversos dispositivos, como máquinas industriais e até mesmo geladeiras e televisões. Estas implementações são escritas e testadas de maneira que elas sempre interpretem o bytecode da mesma forma, ou seja, não existem diferenças entre as instruções, independente de qual a plataforma nativa. Isso torna a linguagem Java muito poderosa, pois permite que um programa escrito e compilado uma única vez possa ser executado em diversos sistemas operacionais e dispositivos, sem precisar de grandes adaptações. Esse era até mesmo o lema comercial do Java, ::Write Once and Run Anywhere::, uma vez escrito e compilado o código, ele pode ser executado em qualquer ambiente que possua uma virtual machine do Java.

Portanto, note que o termo Java é usado em diversos contextos: a linguagem em si, um pacote de bibliotecas - Java Standard Edition ::JSE::, Java Enterprise Edition ::JEE:: etc. - o compilador e a Java Virtual Machine. Tudo isso é o que chamamos de plataforma Java.

Orientação a objetos
Java é uma linguagem de alto nível, orientada a objetos. Mas o que significa ser orientada a objetos?

Orientação a objetos é um paradigma de programação, segundo o qual estruturamos nosso código em entidades conhecidas como objetos, que possuem dentro de si dados na forma de atributos, e comportamento, na forma de métodos.

Objetos são como pequenos componentes especializados em executar uma funcionalidade em um sistema. Inclusive, uma das boas práticas da área é que cada objeto tenha uma única responsabilidade. Assim como no mundo real, para executarmos um determinado comportamento, precisamos da interação de vários objetos/componentes. Por serem componentes independentes e especializados, objetos favorecem o reúso de código e reduzem o custo de manutenção, já que a mudança no comportamento de um objeto será refletida em todos os lugares onde esse objeto é usado.

Encapsulamento
Um dos conceitos mais básicos e importantes da orientação a objetos é o de encapsulamento, a técnica de esconder atributos e detalhes de implementação de um objeto, para que quando eles sejam alterados tal alteração não tenha que ser replicada em vários lugares do sistema.

Em Java, a forma mais simples de se obter um código encapsulado é declarando os atributos de uma classe como private, evitando com isso que outros objetos possam acessar e manipular estes atributos. Caso desejemos que outros objetos tenham acesso a estes dados, liberamos por meio de métodos, controlando como será feita a leitura e escrita das informações.

Vamos ver um exemplo simples, veja a classe Person:


public class Person{
    public String firstName;
    public String lastName;

    public Person(String firstName, String lastName){
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
Desse jeito, qualquer classe no sistema consegue ver estes atributos, e ainda manipulá-los, mudar seus valores. Vamos começar a alterar este código, restringindo o acesso aos atributos usando o modificador de acesso private:


public class Person{
    private String firstName;
    private String lastName;

    public Person(String firstName, String lastName){
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
Ótimo, agora nossos atributos estão encapsulados. Imagine agora que uma outra classe precise imprimir o nome completo de uma pessoa. Vamos implementar esta funcionalidade:



//Person.java
public class Person{
    private String firstName;
    private String lastName;

    public Person(String firstName, String lastName){
        this.firstName = firstName;
        this.lastName = lastName;
    }

    // Expose the full name of the person,
    // but not how it's stored internally
    public String getFullName(){
        return this.firstName + " "
            + this.lastName;
    }
}

//Test.java

class Test{
    public static void main(String[] args){
        Person p = new Person("Mario", "Amaral");
        System.out.print(p.getFullName());
    }
}
Se, por algum motivo, você resolver não armazenar mais o nome e o sobrenome em campos separados, a seguinte alteração será necessária:



//Person.java
public class Person{
    private String fullName;

    public Person(String firstName, String lastName){
        //storing in just one field.
        this.fullName = firstName + " " + this.lastName;
    }

    public String getFullName(){
        return this.fullName;
    }
}

//Test.java
class Test{
    public static void main(String[] args){
        Person p = new Person("Mario", "Amaral");
        System.out.print(p.getFullName());
    }
}
Repare que mudamos a maneira como armazenamos o nome em nossa classe Person, mas não precisamos fazer nenhuma alteração na classe Test. Este é um exemplo de um código bem encapsulado. Alterações são realizadas apenas nas classes cuja implementação vai mudar, e não no sistema inteiro. O encapsulamento vai além de variáveis membro privadas. Veremos detalhes de sua implementação mais à frente, em uma seção dedicada ao tema. Nessa seção da prova será cobrada a vantagem e características dessa técnica.

TIRAR DÚVIDA
