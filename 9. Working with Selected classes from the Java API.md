#Manipulate data using the StringBuilder class and its methods


Manipulando dados usando a classe StringBuilder
PRÓXIMA ATIVIDADE

Para suportar Strings mutáveis, o Java possui as classes StringBuffer e StringBuilder. A operação mais básica é o append que permite concatenar ao mesmo objeto:


StringBuffer sb = new StringBuffer();
sb.append("Caelum");
sb.append(" - ");
sb.append("Ensino e Inovação");

System.out.println(sb);  // Caelum - Ensino e Inovação
Repara que o append não devolve novos objetos como em String, mas altera o próprio StringBuffer, que é mutável.

Podemos criar um objeto desse tipo de diversas maneiras diferentes:


// vazio
StringBuilder sb1 = new StringBuilder(); 
// conteudo inicial
StringBuilder sb2 = new StringBuilder("java"); 
// tamanho inicial do array para colocar a string
StringBuilder sb3 = new StringBuilder(50); 
// baseado em outro objeto do mesmo tipo
StringBuilder sb4 = new StringBuilder(sb2);
Tenha cuidado: ao definir o tamanho do array, não estamos criando uma String de tamanho definido, somente um array desse tamanho que será utilizado pelo StringBuilder, portanto:


StringBuilder sb3 = new StringBuilder(50);
System.out.println(sb3); // linha em branco
System.out.println(sb3.length()); // 0
As classes StringBuffer e StringBuilder têm exatamente a mesma interface (mesmos métodos), sendo que a primeira é ::thread-safe:: e a última não (e foi adicionada no Java 5). Quando não há compartilhamento entre threads, use sempre que possível a StringBuilder, que é mais rápida por não precisar se preocupar com ::locks::.

Inclusive, em Java, quando fazemos concatenação de Strings usando o +, por baixo dos panos, é usado um StringBuilder. Não existe a operação + na classe String. O compilador troca todas as chamadas de concatenação por StringBuilders (podemos ver isso no bytecode compilado).

Principais métodos de StringBuffer e StringBuilder
Há a família de métodos append com overloads para receber cada um dos primitivos, Strings, arrays de chars, outros StringBuffer etc. Todos eles devolvem o próprio StringBuffer/Builder o que permite chamadas encadeadas:


StringBuffer sb = new StringBuffer();
sb.append("Caelum").append(" - ").append("Ensino e Inovação");
System.out.println(sb);  // Caelum - Ensino e Inovação
O método append possui uma versão que recebe Object e chama o método toString de seu objeto.

Há ainda os métodos insert para inserir coisas no meio. Há versões que recebem primitivos, Strings, arrays de char etc. Mas todos têm o primeiro argumento recebendo o índice onde queremos inserir:


StringBuffer sb = new StringBuffer();
sb.append("Caelum - Inovação");
sb.insert(9, "Ensino e ");

System.out.println(sb); // Caelum - Ensino e Inovação
Outro método que modifica é o delete, que recebe os índices inicial e final:


StringBuffer sb = new StringBuffer();
sb.append("Caelum - Ensino e Inovação");
sb.delete(6, 15);

System.out.println(sb); // Caelum e Inovação
Para converter um StringBuffer/Builder em String, basta chamar o toString mesmo. O método reverse inverte seu conteúdo:


System.out.println(new StringBuffer("guilherme").reverse());
                                                // emrehliug
Fora esses, também há o charAt, length(), equals, indexOf, lastIndexOf, substring.

Cuidado, pois o método substring não altera o valor do seu StringBuilder ou StringBuffer, mas retorna a String que você deseja. Existe também o método subSequence que recebe o início e o fim e funciona da mesma maneira que o substring com dois argumentos.

TIRAR DÚVIDA
#Create and manipulate Strings
 Criando e Manipulando Strings
PRÓXIMA ATIVIDADE

Existem duas maneiras tradicionais de criar uma String:


String nomeDireto = "Java";
String nomeIndireto = new String("Java");
A comparação entre esses dois tipos de criação de Strings é feita na seção ::Test equality between strings and other objects using == and equals():: testequality

Existem outras maneiras não tão comuns:


char[] nome = new char[]{'J', 'a', 'v', 'a'};
String nomeComArray = new String(nome);

StringBuilder sb1 = new StringBuilder("Java");
String nome1 = new String(sb1);

StringBuffer sb2 = new StringBuffer("Java");
String nome2 = new String(sb2);
Como uma String não é um tipo primitivo, ela pode ter valor null, lembre-se disso:

String nome = null; // null explicito
Podemos concatenar Strings com o +:

String nome = "Certificação" + " " + "Java";
Caso tente concatenar null com uma String, temos a conversão de null para String:


String nula = null;
System.out.println("nula: " + nula); // imprime nula: null
O Java faz a conversão de tipos primitivos para Strings automaticamente, mas lembre-se da precedência de operadores:


String nome = "Certificação" + ' ' + "Java" + ' ' + 1500;
System.out.println(nome);

String nome2 = "Certificação";
nome2 += ' ' + "Java" + ' ' + 1500;
System.out.println(nome2);

String valor = 15 + 00 + " certificação";
System.out.println(valor); // imprime "15 certificação",
// primeiro efetuando uma soma
Strings são imutáveis
O principal ponto sobre Strings é que elas são imutáveis:


    String s = "caelum";
    s.toUpperCase();
    System.out.println(s);
Esse código imprime caelum em minúscula. Isso porque o método toUpperCase não altera a String original. Na verdade, se olharmos o javadoc da classe String vamos perceber que todos os métodos que parecem modificar uma String na verdade devolvem uma nova.

    String s = "caelum";
    String s2 = s.toUpperCase();
    System.out.println(s2);
Agora sim imprimirá CAELUM, uma nova String. Ou, usando a mesma ::referência:::


    String s = "caelum";
    s = s.toUpperCase();
    System.out.println(s);
Para tratarmos de "strings mutáveis", usamos as classes StringBuffer e StringBuilder.

Lembre-se que a String possui um array por trás e, seguindo o padrão do Java, suas posições começam em 0:


// 0=g, devolve 'g'
char caracter0 = "guilherme".charAt(0);

// 0=g 1=u, devolve 'u'
char caracter1 = "guilherme".charAt(1); 

// 0=g 1=u 2=i, devolve 'i'
char caracter2 = "guilherme".charAt(2);
Cuidado ao acessar uma posição indevida, você pode levar um StringIndexOutOfBoundsException (atenção ao nome da Exception, não é ArrayIndexOutofBoundsException):


char caracter20 = "guilherme".charAt(20); // exception
char caracterMenosUm = "guilherme".charAt(-1); // exception
Principais métodos de String
O método length imprime o tamanho da String:


String s = "Java";
System.out.println(s.length()); // 4
System.out.println(s.length); // não compila: não é atributo
System.out.println(s.size()); // não compila: não existe size
                              // em String Java
Já o método isEmpty diz se a String tem tamanho zero:


System.out.println("".isEmpty()); // true
System.out.println("java".isEmpty()); // false
System.out.println(" ".isEmpty()); // false
Devolvem uma nova String:

String toUpperCase() - tudo em maiúscula;
String toLowerCase() - tudo em minúsculo;
String trim() - retira espaços em branco no começo e no fim;
String substring(int beginIndex, int endIndex) - devolve a substring a partir dos índices de começo e fim;
String substring(int beginIndex) - semelhante ao anterior, mas toma a substring a partir do índice passado até o final da String;
String concat(String) - concatena o parâmetro ao fim da String atual e devolve o resultado;
String replace(char oldChar, char newChar) - substitui todas as ocorrências de determinado char por outro;
String replace(CharSequence target, CharSequence replacement) - substitui todas as ocorrências de determinada CharSequence (como String) por outra.
O método trim limpa caracteres em branco nas duas pontas da String:


System.out.println("     ".trim()); // imprime só a quebra de linha do println
System.out.println(" ".trim().isEmpty()); // true
System.out.println(" guilherme "); // imprime guilherme
System.out.println(". ."); // imprime '. .'
O método replace substituirá todas as ocorrências de um texto por outro:


System.out.println("java".replace("j", "J")); // Java
System.out.println("guilherme".replace("e", "i")); // guilhirmi
Podemos sempre fazer o ::chaining:: e criar uma sequência de "transformações" que retornam uma nova String:


String parseado = "  Quero tirar um certificado oficial de  Java!  ".toUpperCase().trim();

// imprime: "QUERO TIRAR UM CERTIFICADO OFICIAL DE JAVA!"
System.out.println(parseado);
Para extrair pedaços de uma String, usamos o método substring. Cuidado ao usar o método substring com valores inválidos, pois eles jogam uma Exception. O segredo do método susbtring é que ele não inclui o caractere da posição final, mas inclui o caractere da posição inicial:


String texto = "Java";

// ava
System.out.println(texto.substring(1)); 

// StringIndexOutOfBoundsException
System.out.println(texto.substring(-1));

// StringIndexOutOfBoundsException
System.out.println(texto.substring(5));    

// Java
System.out.println(texto.substring(0, 4)); 

// ava
System.out.println(texto.substring(1, 4)); 

// Jav
System.out.println(texto.substring(0, 3)); 

// StringIndexOutOfBoundsException
System.out.println(texto.substring(0, 5));    

// StringIndexOutOfBoundsException
System.out.println(texto.substring(-1, 4));
Comparação:

boolean equals(Object) - compara igualdade caractere a caractere (herdado de Object);
boolean equalsIgnoreCase(String) - compara caractere a caractere ignorando maiúsculas/minúsculas;
int compareTo(String) - compara as 2 Strings por ordem lexicográfica (vem de Comparable);
int compareToIgnoreCase(String) - compara as 2 Strings por ordem lexicográfica ignorando maiúsculas/minúsculas.
E aqui, todas as variações desses métodos. Não precisa saber o número exato que o compareTo retorna, basta saber que será negativo caso a String na qual o método for invocado vier antes, zero se for igual, positivo se vier depois do parâmetro passado:

String texto = "Certificado";
System.out.println(texto.equals("Certificado")); // true
System.out.println(texto.equals("certificado")); // false
System.out.println(texto.equalsIgnoreCase("certificado"));//true

System.out.println(texto.compareTo("Arnaldo")); // 2
System.out.println(texto.compareTo("Certificado")); // 0
System.out.println(texto.compareTo("Grécia")); // -4

System.out.println(texto.compareTo("certificado")); // -32

System.out.println(texto.compareToIgnoreCase("certificado"));//0
Buscas simples:

boolean contains(CharSequence) - devolve true se a String contém a sequência de chars;
boolean startsWith(String) - devolve true se começa com a String do parâmetro;
boolean endsWith(String) - devolve true se termina com a String do parâmetro;
int indexOf(char) e int indexOf(String) - devolve o índice da primeira ocorrência do parâmetro;
int lastIndexOf(char) e int lastIndexOf(String) - devolve o índice da última ocorrência do parâmetro.
O código a seguir exemplifica todos os casos desses métodos:


String texto = "Pretendo fazer a prova de certificação de Java";

System.out.println(texto.indexOf("Pretendo")); // imprime 0
System.out.println(texto.indexOf("Pretendia")); // imprime -1
System.out.println(texto.indexOf("tendo")); // imprime 3

System.out.println(texto.indexOf("a")); // imprime 10
System.out.println(texto.lastIndexOf("a")); // imprime 45
System.out.println(texto.lastIndexOf("Pretendia")); //imprime -1

System.out.println(texto.startsWith("Pretendo")); // true
System.out.println(texto.startsWith("Pretendia")); // false

System.out.println(texto.endsWith("Java")); // true
System.out.println(texto.endsWith("Oracle")); // false
TIRAR DÚVIDA
#Write a simple Lambda expression that consumes a Lambda Predicate expression
 Escreva uma expressão Lambda simples que consuma uma expressão Lambda Predicate
PRÓXIMA ATIVIDADE

Escreva uma expressão Lambda simples que consuma uma expressão Lambda Predicate
Entre as diversas novidades do Java 8, uma que se destaca bastante é a inclusão de ::lambdas::, trazendo algumas características funcionais à linguagem. Para ver melhor a utilidade dos ::lambdas:: e entender o que será cobrado na prova, vamos focar no exemplo a seguir.

Imagine que você precise escrever um método que recebe como parâmetros uma lista e um critério de busca, e retorna outra lista com os elementos que atendem ao critério. Poderíamos implementar este código da seguinte maneira:


class Person {
    private String name;
    private int age;
    //...
}

interface Matcher<T>{
    boolean test(T t);
}

class PersonFilter{

    public List<Person> filter(List<Person> input, 
                               Matcher<Person> matcher){
        List<Person> output = new ArrayList<>();
        for (Person person : input) {
            if(matcher.test(person)){
                output.add(person);
            }
        }    
        return output;
    }
}
Ótimo, nossa base está montada. Agora, para filtrar de uma lista de pessoas apenas as maiores de idade, podemos implementar um Matcher da seguinte maneira:


class AgeOfMajority implements Matcher<Person>{
    @Override
    public boolean test(Person p) {
        return p.getAge() >= 18;
    }
}
E usar esta classe em nosso código:


PersonFilter pf = new PersonFilter();
List<Person> adults = pf.filter(persons, new AgeOfMajority());
O problema dessa abordagem é que, sempre que quisermos um critério diferente, precisamos criar uma nova classe que implemente Matcher, mesmo se for para usar apenas uma vez. Podemos reduzir um pouco esse impacto usando classes anônimas, mas a legibilidade do código fica prejudicada:


List<Person> adults = pf.filter(persons, new Matcher<Person>() {
    @Override
    public boolean test(Person p) {
        return p.getAge() >= 18;
    }
});
É para resolver este tipo de problema que existem os ::lambdas::. Um ::lambda:: é um trecho de código que pode ser passado como parâmetro para um método ou ser armazenado em uma variável para ser invocado posteriormente.

Para usar um ::lambda:: em Java, precisamos de uma interface funcional. Interfaces funcionais são interfaces normais, mas com apenas um método. Nossa interface Matcher pode ser considerada funcional. É possível checar se uma interface é funcional usando a ::annotation:: FunctionalInterface, se não for funcional, o código não compila:


@FunctionalInterface 
interface Matcher<T>{
    boolean test(T t);
}
O Java já vem com várias dessas interfaces funcionais para os cenários comuns. Uma destas interfaces é a Predicate, que recebe um objeto como parâmetro e retorna um boolean, exatamente igual a nosso Matcher. Vamos trocar o código da classe PersonFilter para usar o Predicate:


import java.util.function.Predicate;

class PersonFilter{

    public List<Person> filter(List<Person> input,
                               Predicate<Person> matcher){
        List<Person> output = new ArrayList<>();
        for (Person person : input) {
            if(matcher.test(person)){
                output.add(person);
            }
        }    
        return output;
    }
}
E para fazer o filtro:


Predicate<Person> matcher = new Predicate<Person>() {
    @Override
    public boolean test(Person p) {
        return p.getAge() >= 18;
    }
};
List<Person> adults = pf.filter(persons, matcher);
Ok, vamos converter este código para um ::lambda::. A sintaxe básica do lambda é a seguinte:

( parameters ) -> { code }
Usando esta fórmula no código anterior temos o seguinte:


Predicate<Person> matcher =
    (Person p) -> {return p.getAge() >= 18;};
Perceba quanto código foi removido. Praticamente toda a declaração do tipo, de que não precisamos, já que a declaração do tipo da variável tem o mesmo de forma explícita. Também removemos o nome do método, que também não é necessário, já que interfaces funcionais possuem apenas um método.

Podemos remover mais código ainda. Repare que a variável matcher é do tipo Predicate<Person>. Aqui podemos inferir o tipo do parâmetro pelo tipo ::generics:: da interface. o código fica:


Predicate<Person> matcher = (p) -> {return p.getAge() >= 18;};
Se temos apenas um argumento, podemos ainda remover os parênteses:


Predicate<Person> matcher = p -> {return p.getAge() >= 18;};
Se temos apenas uma linha de código dentro do ::lambda::, podemos omitir as chaves. Se esta linha for o retorno, podemos omitir a palavra return também:


Predicate<Person> matcher = p -> p.getAge() >= 18;
Pronto, já retiramos bastante código, está bem mais limpo. Nosso código no final fica assim:


Predicate<Person> matcher = p -> p.getAge() >= 18;
List<Person> adults = pf.filter(persons, matcher);
Não somos obrigados a armazenar o ::lambda:: em uma variável, podemos passá-lo diretamente como parâmetro do método:


List<Person> adults = pf.filter(persons, p -> p.getAge() >= 18);
Vamos entender qual a vantagem desta abordagem. Se agora precisarmos de um outro filtro, que retorna apenas as pessoas cujo nome comece com a letra "A", podemos simplesmente fazer:


List<Person> namesStartingWithA =
    pf.filter(persons, p -> p.getName().startsWith("A"));
Não há necessidade de criar classes, nem mesmo anônimas. A inclusão dos ::lambdas:: nos permite escrever código altamente adaptável e ainda reduzir muito a verbosidade comum do Java.

Antes de passar para o próximo exemplo, vamos entendera regras para se escrever um ::lambda::.

::Lambdas:: podem ter vários argumentos, como um método. Basta separá-los por ,.
O tipo dos parâmetros pode ser inferido e, assim, omitido da declaração.
Se não houver nenhum parâmetro, é necessário incluir parênteses vazios, como em:

Runnable r = () -> System.out.println("a runnable object!");
Se houver apenas um parâmetro, podemos omitir os parênteses, como em:

Predicate<Person> matcher = p -> p.getAge() >= 18;
O corpo do ::lambda:: pode conter várias instruções, assim como um método.
Se houver apenas uma instrução, podemos omitir as chaves, como em :

Predicate<Person> matcher = p -> p.getAge() >= 18;
Se houver mais de uma instrução, é necessário delimitar o corpo do ::lambda:: com chaves, como em:

Runnable r = () ->  { 
    int a = 10;
    int b = 20;
    System.out.println(a + b);
}
Acessando variáveis do objeto com ::lambdas::
::Lambdas:: podem interagir com as variáveis de instância dos objetos onde foram declarados. Temos apenas que tomar cuidado com variáveis marcadas como final:


public class LambdaScopeTest {

    public int instanceVar = 1;
    public final int instanceVarFinal = 2;

    public static void main(String[] args) {
        new LambdaScopeTest().test();
    }

    private void test() {
        instanceVar++; // ok
        new Thread(() -> {
            System.out.println(instanceVar); // ok
            instanceVar++; // ok

            System.out.println(instanceVarFinal); // ok
            instanceVarFinal++; // compile error
        }).start();
    }
Já com variáveis locais de método e parâmetros, as regras são um pouco mais complexas. ::Lambdas:: só podem interagir com variáveis locais caso estas estejam marcadas como final (uma referência imutável) ou que sejam efetivamente final (não são final, mas não são alteradas). Não é possível alterar o valor de nenhuma variável local dentro de um ::lambda:::


    private void test() {
        int unchangedLocalVar = 3;   // effectively final
        final int localVarFinal = 4; // final
        int simpleLocalVar = 0;
        simpleLocalVar = 9; // updated the value

        new Thread(() -> {
            System.out.println(unchangedLocalVar);   // can read 
            System.out.println(localVarFinal);       // can read
            System.out.println(simpleLocalVar); // compile error
        }).start();
    }
Conflitos de nomes com ::lambdas::
As variáveis do ::lambda:: são do mesmo escopo que o método onde ele foi declarado, portanto, não podemos declarar nenhuma variável, como parâmetro ou dentro do corpo, cujo nome conflite com alguma variável local do método:


private void test(String param) {
    String methodVar = "method"; //not final

    Predicate<String> a = 
        param -> param.length() > 0; //compile error
    Predicate<String> b = 
        methodVar -> methodVar.length() > 0; //compile error
    Predicate<String> c = 
        newVar -> newVar.length() > 0; // ok
}
TIRAR DÚVIDA
#Trabalhando com saída no console
Trabalhando com saída no console
PRÓXIMA ATIVIDADE

Imprimindo no console padrão
Para imprimir na saída do console, podemos usar o método print* do objeto out, da classe System:


System.out.print("hello world");
System.out é um PrintStream
O out é um atributo estático e público da classe System, do tipo PrintStream. A classe PrintStream possui vários métodos que permitem escrever diversos tipos de dados de maneira padronizada em um OutputStream.

O método print possui várias sobrecargas, recebendo desde ::strings:: até tipos primitivos:


System.out.print(false); // a boolean
System.out.print(10.3);  // a double value
System.out.print("Some text"); // some text
Também existe uma versão de print que recebe Object, ou seja, qualquer objeto. Neste caso, será invocado o método toString do objeto passado:


class Test {

    public String toString(){
        return "My test object...";
    }

    public static void main(String[] args){
        System.out.print(new Test()); // My test object...
    }
}
Existe um único caso especial que foge à regra; além de primitivos, ::strings:: e Object, existe também uma sobrecarga que recebe um array de char. Todos os outros ::arrays:: são tratados como Object


char[] c = {'a','b','c'};
int[] i = {1,2,3};
System.out.print(c); // abc
System.out.print(i); // [I@9d8643e (ou similar)]
O método print apenas imprime o valor passado. Se invocado várias vezes em sequência, todos os valores serão impressos em uma única linha:


System.out.print(false);
System.out.print(10.3);
System.out.print("Some text");
Esse código imprime:


false10.3Some text
Podemos imprimir cada conteúdo em uma linha diferente, concatenando um "\n" após cada impressão. Para este caso, existe o método println, que adiciona uma quebra de linha após cada chamada:


System.out.println(false);
System.out.println(10.3);
System.out.println("Some text");
Já esse código imprime:


false
10.3
Some text
O println possui as mesmas sobrecargas que o método print, além de uma versão sem nenhum parâmetro, que apenas quebra uma linha:


System.out.print("foo");
System.out.println(); // line break
System.out.print("bar");
Imprime


foo
bar
Formatando a impressão
Na versão 5 do Java, foram incluídos dois métodos para permitir a impressão no console de modo formatado, format e printf. Ambos se comportam exatamente da mesma maneira, sendo que o printf foi incluído provavelmente apenas para manter uma sintaxe próxima à da linguagem C, na qual existe um método com comportamento similar com este nome. Sendo assim, tudo o que discutirmos sobre um método serve para o outro.

O printf recebe dois parâmetros: o primeiro é uma String que pode conter apenas texto normal ou incluir caracteres especiais de formatação; o segundo é um varargs de objetos a serem usados na impressão. Vamos começar com um exemplo simples:


System.out.printf("Hello %s, have a nice day!", "Mario");
Esse código imprime:


Hello Mario, have a nice day!
Perceba o caractere % na mensagem. É ele que indica que ali temos uma formatação especial. O s logo em seguida ao % indica que lá incluiremos alguma outra String, que é a que passamos como segundo argumento deste método. O próprio método se encarrega de fazer a concatenação no lugar certo e exibir o resultado no console, o que chamamos de interpolação de String (::string interpolation::).

Para indicar como a formatação deve ser feita, usamos a seguinte estrutura, que veremos com mais detalhes a partir de agora:


%[index$][flags][width][.precision]type
Todas as opções entre [ ] são opcionais. Somos obrigados a informar apenas o caractere de % e o tipo do argumento que será concatenado. Vamos analisar cada opção separadamente:

type é o tipo de argumento que será passado e suporta os seguintes valores:

b - boolean
c - char
d - Números inteiros
f - Números decimais
s - String
n - Quebra de linha
Vejamos alguns exemplos:


System.out.printf("%s %n", "foo"); //foo
System.out.printf("%b %n", false); //false
System.out.printf("%d %n", 42);    //42
System.out.printf("%d %n", 1024L); //1024
System.out.printf("%f %n", 23.9f); //23.900000
System.out.printf("%f %n", 44.0);  //44.000000
Repare que podemos passar mais de uma instrução por impressão, sendo que cada % está relacionado com o próximo parâmetro passado na sequência:


System.out.printf("%s, it's %b, the result is %d", "yes",
                  true, 100);
Esse código imprime:


yes, it's true, the result is 100
O index é um número inteiro delimitado pelo caractere $, que indica qual dos argumentos deve ser impresso nessa posição se desejarmos fugir do padrão sequencial. Por exemplo:


System.out.printf("%2$s %1$s", "World","Hello"); // Hello World
Mesmo passando os argumentos fora de ordem, conseguimos indicar na ::string:: qual a ordem que queremos na impressão. Esse recurso é extremamente interessante quando queremos repetir o mesmo valor em dois pontos da nossa formatação.

width indica a quantidade mínima de caracteres para imprimir. Completa com espaços à esquerda caso o valor seja menor que a largura mínima. Caso seja maior, não faz nada:


System.out.printf("[%5d]%n", 22);       //[   22]
System.out.printf("[%5s]%n", "foo");    //[  foo]
System.out.printf("[%5s]%n", "foofoo"); //[foofoo]
flags são caracteres especiais que alteram a maneira como a impressão é feita. Para a prova, é importante conhecer alguns, dentre os quais os dois que indicam se o número é positivo ou negativo:

+ - Sempre inclui um sinal de positivo (+) ou negativo (-) em números.
( - Números negativos são exibidos entre parênteses.
Dois de alinhamento à esquerda ou direita:

- - Alinha à esquerda. Precisa de tamanho para ser usado.
0 - Completa a esquerda com zeros. Precisa de tamanho para ser usado.
Juntamente com o tamanho mínimo, podemos usar a ::flag:: de alinhamento e de completar com zeros:


System.out.printf("[%05d]%n", 22);    //[00022]
System.out.printf("[%-5s]%n", "foo"); //[foo  ]
Só é possível completar com zeros quando estamos formatando números. Tentar usar esta flag com ::strings:: lança uma FormatFlagsConversionMismatchException, como em:


System.out.printf("[%05s]%n", "foo");
Temos uma flag para separar casa de milhares e decimais:

, - Habilita separadores de milhar e decimal.
Vamos ver alguns exemplo:


System.out.printf("%+d %n", 22);       //+22 
System.out.printf("%,f %n", 1234.56);  //1,234.560000
System.out.printf("%(f %n", -1234.56); //(1234.560000)
A impressão de separadores de milhar e decimal depende da linguagem do sistema onde o código é executado. Podemos alterar o padrão usando um objeto da classe Locale, que altera as regras padrões para as regras da língua informada:


Locale br = new Locale("pt","BR");
System.out.printf(br,"%,f %n", 123456.789); // 123.456,789000
Quando da formatação de números com casas decimais, precision indica quantas casas queremos depois da vírgula, basta usar um . seguido do número de caracteres. Vale lembrar que só é possível mudar a precisão quando estamos formatando números decimais.


System.out.printf("[%.2f]%n", 22.5); //[22.50]
TIRAR DÚVIDA
