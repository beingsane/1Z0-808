#Differentiate among checked exceptions, unchecked exceptions, and Errors
Diferencie entre exceções do tipo checked, runtime e erros
PRÓXIMA ATIVIDADE

Durante a execução de uma aplicação, erros podem acontecer. A linguagem Java oferece um mecanismo para que o programador possa definir as providências apropriadas a serem tomadas na hora em que um erro de execução ocorrer.

Os erros de execução são classificados em algumas categorias. É fundamental que você seja capaz de, dado um erro de execução, determinar seu tipo. A classificação das categorias depende exclusivamente da hierarquia das classes que modelam os erros de execução.

A classe principal dessa hierarquia é a Throwable. Qualquer erro de execução é um objeto dessa classe ou de uma que deriva dela.

Como filhas diretas de Throwable temos: Error e Exception.

Os Errors são erros de execução gerados por uma situação totalmente anormal que não deveria ser prevista pela aplicação. Por exemplo, um OutOfMemoryError é gerado quando a JVM não tem mais memória RAM disponível para oferecer para as aplicações. Em geral, esse tipo de erro não é responsabilidade das aplicações pois quem cuida do gerenciamento de memória é a JVM.

Por outro lado, as Exceptions são erros de execução que são de responsabilidade das aplicações, ou seja, são as aplicações que devem tratar ou evitar esses erros. Por exemplo, um SQLException é gerado quando algum erro ocorre na comunicação entre a aplicação e o banco de dados. Esse tipo de erro deve ser tratado ou evitado pela aplicação.

Por sua vez, as Exceptions são divididas em duas categorias: as uncheckeds e as checkeds. As ::uncheckeds:: são exceptions que teoricamente podem ser mais facilmente evitadas pelo próprio programador se ele codificar de maneira mais cuidadosa. As ::checkeds:: são exceptions que teoricamente não são fáceis de evitar, de modo que a melhor abordagem é estar sempre preparado para seu acontecimento.

As uncheckeds são definidas pelas classes que derivam de RuntimeException, que por sua vez é filha direta de Exception. As outras classes na árvore da Exception definem as checkeds.



Essas diferenças não ficam apenas na teoria. O compilador irá verificar se seu programa pode lançar alguma checked exception e, neste caso, obrigá-lo a tratar essa exception de alguma maneira. No caso das exceptions unchecked, não há nenhuma verificação por parte do compilador pelo tratamento ou não.

TIRAR DÚVIDA
#Create a try-catch block and determine how exceptions alter normal program flow
Crie um bloco try-catch e determine como exceções alteram o fluxo normal de um programa
PRÓXIMA ATIVIDADE

O programador pode definir um tratamento para qualquer tipo de erro de execução. Antes de definir o tratamento, propriamente, é necessário determinar o trecho de código que pode gerar um erro na execução. Isso tudo é feito com o comando try-catch.


try {
    // trecho que pode gerar um erro na execução.
} catch (Throwable t) { // pegando todos os possíveis erros de 
                        //execução.
    // tratamento para o possível erro de execução.
}
A sintaxe do try-catch tem um bloco para o programador definir o trecho de código que pode gerar um erro de execução. Esse bloco é determinado pela palavra try. O programador também pode definir quais tipos de erro ele quer pegar para tratar. Isso é determinado pelo argumento do catch. Por fim, o tratamento é definido pelo bloco que é colocado após o argumento do catch.

Durante a execução, se um erro acontecer, a JVM redireciona o fluxo de execução da linha do bloco do try que gerou o erro para o bloco do catch. Importante! As linhas do bloco do try abaixo daquela que gerou o erro não serão executadas.

Fazer um catch em Throwable não é uma boa prática, pois todos os erros possíveis são tratados pela aplicação. Porém, os Errors não deveriam ser tratados pela aplicação, já que são de responsabilidade da JVM. Assim, também não é boa prática dar catch em Errors.

Modificando o argumento do catch, o programador define quais erros devem ser pegos para serem tratados.


try {
    // trecho que pode gerar um erro na execução.
} catch (Exception e) { // pegando todas as exceptions.
    // tratamento para o possível erro de execução.
}
Para a prova, é fundamental saber quando o programador pode ou não pode usar o try-catch. A única restrição de uso do try-catch envolve as checked exceptions. Qual é a regra? O programador só pode usar try-catch em uma checked exception se o código do bloco do try pode realmente lançar a checked exception em questão.


try {
    System.out.println("não acontece SQLException");
} catch(SQLException e){ // pegando SQLException.
    // tratamento.
}
Esse código não compila pois o trecho envolvido no bloco do try nunca geraria a checked SQLException. O compilador avisa com um erro de "unreachable code". Já o exemplo a seguir compila, pois pode ocorrer um FileNotFoundException:


try {
    new java.io.FileInputStream("a.txt");
} catch(java.io.FileNotFoundException e){
    // tratamento.
}
O código a seguir não tem nenhum problema, pois o programador pode usar o try-catch em qualquer situação para os erros de execução que não são checked exceptions.


try {
    System.out.println("Ok");
} catch (RuntimeException e) { // pegando RuntimeException 
                               // (unckecked).
    // tratamento.
}
Podemos pegar tudo, exceptions e erros:


try {
    System.out.println("Ok");
} catch (Throwable e) { 
    // tratamento
}
Quando a exception é pega, o fluxo do programa é sair do bloco try e entrar no bloco catch, portanto, o código a seguir imprime peguei e continuando normal:


String nome = null;
try {
    nome.toLowerCase();
    System.out.println("segunda linha do try");
} catch(NullPointerException ex) {
    System.out.println("peguei");
}
System.out.println("continuando normal");
Mas, se a exception que ocorre não é a que foi definida no catch, a chamada do método para e volta, jogando a exception como se não houvesse um try/catch. O cenário a seguir demonstra essa situação e não imprime nada:


String nome = null;
try {
    nome.toLowerCase();
    System.out.println("segunda linha do try");
} catch(IndexOutOfBoundsException ex) {
    System.out.println("peguei");
}
System.out.println("continuando normal");
Lembre-se sempre do polimorfismo, portanto, pegar IOException é o mesmo que pegar todas as filhas de IOException também. O código a seguir trata o caso de o arquivo não existir além de todas as outras filhas de IOException:


try {
    new java.io.FileInputStream("a.txt");
} catch(java.io.IOException e){
    // tratamento.
}
Bloco finally
Tem coisas que não podemos deixar de fazer em hipótese alguma. Seja no sucesso ou no fracasso, temos obrigação de cumprir com algumas tarefas.

Imagine um método que conecta com um banco de dados. Não importa o que aconteça, no fim desse método a conexão deveria ser fechada. Durante a comunicação com o banco de dados, há o risco de ocorrer uma SQLException.


void metodo(){
    try {
        abreConexao();
        fazConsultas();
        fechaConexao();
    } catch (SQLException e) {
        // tratamento
    }
}
Nesse código, há um grande problema: se um SQLException ocorrer durante as consultas, a conexão com o banco de dados não será fechada. Para tentar resolver esse problema, o bloco do catch poderia invocar o método fechaConexao(). Então, se acontecesse um SQLException o bloco do catch seria executado e, consequentemente, a conexão seria fechada.

Mas ainda não solucionamos o problema, pois outro tipo de erro poderia acontecer nas consultas. Por exemplo, uma NullPointerException que não está sendo tratada. Para resolver o problema de fechar a conexão, um outro recurso do Java será utilizado, o bloco finally. Esse bloco é sempre executado, tanto no sucesso quanto no fracasso por qualquer tipo de erro.


void metodo(){
    try {
        abreConexao();
        fazConsultas(); // Não precisa mais fechar a conexao 
                        // aqui.
    } catch(SQLException e) {
        // tratamento
    } finally {
        fechaConexao(); // fechando a conexao no sucesso ou no
                        // fracasso.
    }
}
Para melhor entender o fluxo do try-cacth com o finally, veja o próximo exemplo.


class A {
    void metodo() {
        try{
            //A
            //B
        }catch(SQLException e){
            //C
        }finally{
            //D
        }
        //E
    }
}
Em uma execução normal, sem erros nem exceções, ele executaria A, B, D, E.
Com SQLException em A, ele executaria C, D, E.
Com NullPointerException em A, ele executaria apenas D e sairia.
Se A fosse um System.exit(0);, ele apenas executa A e encerra o programa.
Se ocorresse um erro A, executaria apenas D (dependendo do erro).
Uma outra maneira um pouco menos convencional de usar o finally é sem o bloco catch, como no exemplo a seguir.


class A{
  void metodo() {
    try {
      System.out.println("imprime algo");
    } finally {
      // sempre permite fechar
    }
  }
}
TIRAR DÚVIDA
#Describe the advantages of Exception handling
Descreva o que são exceções e para que são utilizadas em Java
PRÓXIMA ATIVIDADE

Imagine a situação em que tentamos acessar uma posição em um array:


public void fazAlgo(int[] idades) {
    System.out.println(idades[0]);
}
O que acontece se o array enviado para o método é vazio? Se esse código imprimisse nulo ou um número padrão, nesse caso, teríamos sempre que nos preocupar, como em:


public void fazAlgo(int[] idades) {
    if(idades[0]==null) return; 
    // return para caso o Java devolva nulo ao acessar 
    // uma posição inválida

    System.out.println(idades[0]);
}
Pense como seria difícil tratar todas as situações possíveis que fogem do padrão de comportamento que estamos desejando. Nesse caso, o comportamento padrão, aquilo que acontece 99% das vezes e que esperamos que aconteça é que a posição acessada dentro do array seja válido. Não queremos ter que verificar toda vez se o valor é válido, e não queremos entupir nosso código com diversos ifs para diversas condições. As exceções à regra, as exceptions, são a alternativa para o controle de fluxo: em vez de usarmos ifs para controlar o fluxo que foge do padrão, é possível usar as exceptions para esse papel. Veremos adiante como tratar erros, como o acesso a posições inválidas, tentar acessar variáveis com valores inválidos etc.

Caso uma exception estoure e sua stack trace seja impressa, teremos algo como:


Exception in thread "main"
java.lang.ArrayIndexOutOfBoundsException: 0
    at SuaClasse.fazAlgo(SuaClasse.java:20)
    at SuaClasse.main(SuaClasse.java:30)
Note como a stack trace indica que método estava sendo invocado, em qual linha do arquivo fonte está essa invocação, quem invocou este método etc.

O importante é lembrar que as exceptions permitem que isolemos o tratamento de um comportamento por blocos, separando o bloco de lógica de nosso negócio do bloco de tratamentos de erros (sejam eles Exceptions ou Errors, como veremos adiante). O stack trace de uma Exception também ajuda a encontrar onde exatamente o problema ocorreu e o que estava sendo executado naquela Thread naquele instante.

TIRAR DÚVIDA
#Create and invoke a method that throws an exception
Invoque um método que joga uma exceção
PRÓXIMA ATIVIDADE

Eventualmente, um método qualquer não tem condição de tratar um determinado erro de execução. Nesse caso, esse método pode deixar passar o erro para o próximo método na pilha de execução.

Para deixar passar qualquer erro de execução que não seja uma checked exception, é muito simples: basta não fazer nada.


class Teste {

    void primeiro(){
        System.out.println("primeiro antes");
        this.segundo();
        System.out.println("primeiro depois");
    }

    void segundo() {
        String s = null;
        System.out.println("segundo antes");
        s.length();
        System.out.println("segundo depois");
    }
}
O segundo método declara uma variável não primitiva e a inicializa com null. Logo em seguida, ele utiliza o operador . em uma referência que sabemos estar nula. Nesse ponto, na hora da execução, um NullPointerException é gerado. Perceba que não há try-catch no segundo método, então ele não está pegando e tratando o erro, mas sim deixando-o passar. O primeiro método não define o try-catch, ou seja, também deixa passar o NullPointerException. O resultado é a impressão de primeiro antes, segundo antes.

Agora, para deixar passar uma checked exception, o método é obrigado a deixar explícito (avisado) que pretende deixar passar. Na assinatura do método, o programador pode deixar avisado que pretende deixar passar determinados erros de execução. Isso é feito através da palavra-chave throws.


class Teste {

    void primeiro(){
        try {
            System.out.println("primeiro antes");
            this.segundo();
            System.out.println("primeiro depois");
        } catch(IOException e) {
            // tratamento.
            System.out.println("primeiro catch");
        }
        System.out.println("primeiro fim");
    }

    void segundo() throws IOException {
        System.out.println("segundo antes");
        System.in.read(); // pode lançar IOException
        System.out.println("segundo depois");
    }
}
O segundo método invoca o read() no System.in. Essa invocação pode gerar um IOException, de modo que o segundo método tem duas alternativas: ou pega e trata o possível erro ou o deixa passar. Para deixar passar, o comando throws deve ser utilizado na sua assinatura do segundo método. Isso indicará que um IOException pode ser lançado.

Dessa forma, o primeiro método que invoca o segundo pode receber uma IOException. Então, ele também tem duas escolhas: ou pega e trata usando try-catch, ou deixa passar usando o throws. O resultado é a impressão de primeiro antes, segundo antes, primeiro catch e primeiro fim.

Gerando um erro de execução
Qualquer método, ao identificar uma situação errada, pode criar um erro de execução e lançar para quem o chamou. Vale lembrar que os erros de execução são representados por objetos criados a partir de alguma classe da hierarquia da classe Throwable, logo, basta o método instanciar um objeto de qualquer uma dessas classes e depois lançá-lo.

Se o erro não for uma checked exception, basta criar o objeto e utilizar o comando throw para lançá-lo na pilha de execução (não confunda com o throws):


class Teste {

    void primeiro(){
        try {
            this.segundo();
        } catch (RuntimeException e) {
            // tratamento.
        }
    }

    void segundo() {
        throw new RuntimeException();
    }
}
Se o erro for uma checked exception, é necessário também declarar na assinatura do método o comando throws:


class Teste {

    void primeiro(){
        try {
            this.segundo();
        } catch(Exception e) {
            // tratamento.
        }
    }

    void segundo() throws Exception {
        throw new Exception();
    }
}
Podemos ainda criar nossas próprias exceções, bastando criar uma classe que entre na hierarquia de Throwable.


class MinhaException extends Exception{}
Em qualquer lugar do código, é opcional o uso do try e catch de uma unchecked exception para compilar o código. Em uma checked exception, é obrigatório o uso do try/catch ou throws.

O exemplo a seguir mostra uma unchecked exception sendo ignorada e o erro vazando, e nada será impresso:


public class Teste {

    public static void main(String[] args) {
        metodo();
        System.out.println("Apos a invocacao do metodo");
    }

    private static void metodo() {
        int[] i= new int[10];
        System.out.println(i[15]);
        System.out.println("Apos a exception");
    }

}
Ao pegarmos a exception, será impresso também "Apos a invocacao do metodo" uma vez que após o catch, o fluxo volta ao normall:


public class Teste {

    public static void main(String[] args) {
        try {
            metodo();
        } catch(RuntimeException ex) {
            System.out.println("Exception pega");
        }
        System.out.println("Apos a invocacao do metodo");
    }

    private static void metodo() {
        int[] i= new int[10];
        System.out.println(i[15]);
        System.out.println("Apos a exception");
    }

}
Podemos ter também múltiplas expressões do tipo catch. Nesse caso, será invocada somente a cláusula adequada, e não as outras. No código a seguir, se o metodo2 jogar uma ArrayIndexOutOfBoundsException, será impresso runtime:


void metodo1() {
    try {
        metodo2();
    } catch(IOException ex) {
        System.out.println("io");
    } catch(RuntimeException ex) {
        System.out.println("runtime");
    } catch(Exception ex) {
        System.out.println("exception qualquer");
    }
}
E a ordem faz diferença? Sim, o Java procura o primeiro catch que pode trabalhar a Exception adequada.

Repare que RuntimeException herda de Exception e, portanto, deve vir antes da mesma na ordem de catches.

Caso ela viesse depois, ela nunca seria invocada, pois o Java verificaria que toda RuntimeException é Exception e Exception teria tratamento de preferência (por sua ordem). O exemplo a seguir não compila por este motivo:


void metodo1() {
    try {
        metodo2();
    } catch(IOException ex) {
        System.out.println("io");
    } catch(Exception ex) {
        System.out.println("exception qualquer");
    } catch(RuntimeException ex) { 
        // não compila pois jamais será executado
        System.out.println("runtime");
    }
}
Cuidado também com exceptions nos inicializadores:


class AcessoAoArquivo {
    // não compila, pois ao instanciar, pode dar IOException,
    // mas o construtor não fala nada
    private InputStream is = new FileInputStream("entrada.txt"); 
}
Nesses casos, precisamos dizer no construtor que a Exception pode ser jogada:


class AcessoAoArquivo {
    private InputStream is = new FileInputStream("entrada.txt");

    AcessoAoArquivo() throws IOException{
        // estou avisando os clientes dessa classe
        // que ao instanciar pode dar essa exception
        // e agora compila
    }
}
TIRAR DÚVIDA
#Recognize common exception classes (such as NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException, ClassCastException)
Reconheça classes de exceções comuns e suas categorias
PRÓXIMA ATIVIDADE

Para a prova, é necessário conhecer algumas exceptions clássicas do Java. Na sequência, vamos conhecer essas exceptions e entender em que situações elas ocorrem.

ArrayIndexOutOfBoundsException e IndexOutOfBoundsException
Um ArrayIndexOutOfBoundsException ocorre quando se tenta acessar uma posição que não existe em um array.


class Teste {
    public static void main(String[] args) {
        int[] array = new int[10];
        array[10] = 10; // Aqui ocorre 
                        // ArrayIndexOutOfBoundsException.
    }
}
Da mesma maneira, quando tentamos acessar uma posição não existente em uma lista , a exception é diferente, no caso IndexOutOfBoundsException:


class Teste {
    public static void main(String[] args) {
        ArrayList<String> lista = new ArrayList<String>();

        //Aqui ocorre IndexOutOfBoundsException
        String valor = lista.get(2); 
    }
}
NullPointerException
Toda vez que o operador . é utilizado em uma referência nula, um NullPointerException é lançado.


class Teste {
    public static void main(String[] args) {
        String s = null;
        s.length(); // Aqui ocorre uma NullPointerException
    }
}
ClassCastException
Quando é feito um casting em uma referência para um tipo incompatível com o objeto que está na memória em tempo de execução, ocorre um ClassCastException.


class Teste {
    public static void main(String[] args) {
        Object o = "SCJP"; // String
        Integer i = (Integer)o; // Aqui ocorre 
                                // ClassCastException.
    }
}
NumberFormatException
Um problema comum que o programador enfrenta no dia a dia é ter que "transformar" texto em números. A API do Java oferece diversos métodos para tal tarefa. Porém, em alguns casos não é possível "parsear" o texto, pois ele pode conter caracteres incorretos.


class Teste {
    public static void main(String[] args) {
        String s = "ABCD1";

        // Aqui ocorre um NumberFormatException.
        int i =    Integer.parseInt(s); 
    }
}
IllegalArgumentException
Qualquer método deve verificar se os valores passados nos seus parâmetros são válidos. Se um método constata que os parâmetros estão inválidos, ele deve informar quem o invocou que há problemas nos valores passados na invocação. Para isso, é aconselhado que o método lance IllegalArgumentException.


class Teste {
    public static void main(String[] args) {
        try {
            divideEImprime(5,0);
        } catch (IllegalArgumentException e) {
            // tratamento.
        }
    }

    public static void divideEImprime(int i, int j) {
        if(j == 0) { // Evita dividir por zero.
            throw new IllegalArgumentException();
        }
        System.out.println(i/j);
    }
}
IllegalStateException
Suponha que uma pessoa possa fazer três coisas: dormir, acordar e andar. Para andar, a pessoa precisa estar acordada. A classe Pessoa modela o comportamento de uma pessoa. Ela contém um atributo boolean que indica se a pessoa está acordada ou dormindo e um método para cada coisa que uma pessoa faz (dormir(), acordar() e andar()).

O método andar() não pode ser invocado enquanto a pessoa está dormindo. Mas, se for, ele deve lançar um erro de execução. A biblioteca do Java já tem uma classe pronta para essa situação, a classe é a IllegalStateException. Ela significa que o estado atual do objeto não permite que o método seja executado.


class Pessoa {
    boolean dormindo = false;

    void dormir() {
        this.dormindo = true;
        System.out.println("dormindo...");
    }
    void acordar() {
        this.dormindo = false;
        System.out.println("acordando...");
    }
    void andar() {
        if(this.dormindo) { // Só pode andar acordado.
            throw new IllegalStateException("Deveria estar 
                                             acordado!"); 
        }

        System.out.println("andando...");
    }        
}
ExceptionInInitializerError
No momento em que a máquina virtual é disparada, ela não carrega todo o conteúdo do classpath, em outras palavras, ela não carrega em memória todas as classes referenciadas pela sua aplicação.

Uma classe é carregada no momento da sua primeira utilização. Isso se dá quando algum método estático ou atributo estático são acessados ou quando um objeto é criado a partir da classe em questão.

No carregamento de uma classe, a JVM pode executar um trecho de código definido pelo programador. Esse trecho deve ficar no que é chamado bloco estático.


class A {
    static {
        // trecho a ser executado no carregamento da classe.
    }
}
É totalmente possível que algum erro de execução seja gerado no bloco estático. Se isso acontecer, a JVM vai "embrulhar" esse erro em um ExceptionInInitializerError e dispará-lo.

Esse erro pode ser gerado também na inicialização de um atributo estático se algum problema ocorrer. Exemplo:


class A {
    static {
        if(true)
            throw new RuntimeException("nao vou deixar nao...");
    }
}

public class Teste {

    public static void main(String[] args) {
        new A();
    }
}
Gera o erro de inicialização:


Exception in thread "main" java.lang.ExceptionInInitializerError
    at Teste.main(Teste.java:11)
Caused by: java.lang.RuntimeException: nao vou deixar nao...
    at A.<clinit>(Teste.java:4)
    ... 1 more
StackOverflowError
Todos os métodos invocados pelo programa Java são empilhados na Pilha de Execução. Essa pilha tem um limite, ou seja, ela pode estourar:


class Teste {
    public static void main(String[] args) {
        metodoSemFim();
    }

    static void metodoSemFim() {
        metodoSemFim();
    }
}
Repare que, nesse exemplo, o metodoSemFim() chama ele mesmo (recursão). Do jeito que está, os métodos serão empilhados eternamente e a pilha de execução vai estourar.

NoClassDefFoundError
Na etapa de compilação, todas as classes referenciadas no código-fonte precisam estar no classpath. Na etapa de execução também. O que será que acontece se uma classe está no classpath na compilação mas não está na execução? Quando isso acontecer será gerado um NoClassDefFoundError.

Para gerá-lo, podemos criar um arquivo com duas classes onde uma referencia a outra:


class OutraClasse {

}
class Teste {
    public static void main(String[] args) {
        new OutraClasse();
    }
}
Compilamos o arquivo, gerando dois arquivos .class. Aí apagamos o arquivo OutraClasse.class. Pronto, o Java não será capaz de encontrar a classe, dando um erro, NoClassDefFoundError.

OutOfMemoryError
Durante a execução de nosso código, o Java vai gerenciando e limpando a memória usada por nosso programa automaticamente, usando o garbage collector (GC). O GC vai remover da memória todas as referências de objetos que não são mais utilizados, liberando o espaço para novos objetos. Mas o que acontece quando criamos muito objetos, e não os liberamos? Nesse cenário, o GC não vai conseguir liberar memória, e eventualmente a memória livre irá acabar, ocasionando um OutOfMemoryError.

O código para fazer um erro do gênero é simples, basta instanciar infinitos objetos, sem permitir que o garbage collector jogue-os fora. Fazemos isso com Strings para que o erro aconteça logo:


void metodo() {
    ArrayList<String> objetos = new ArrayList<String>();
    String atual = "";
    while(true) {
        atual += " ficou maior";
        objetos.add(atual);
    }
}
TIRAR DÚVIDA
#Create and manipulate calendar data using classes from java.time.LocalDateTime,  java.time.LocalDate, java.time.LocalTime, java.time.format.DateTimeFormatter, java.time.Period
Crie e manipule dados de calendários usando as classes do pacote java.time
PRÓXIMA ATIVIDADE

Java 8 - Trabalhando com algumas classes da Java API
Crie e manipule dados de calendários usando as classes java.time.LocalDateTime, java.time.LocalDate, java.time.LocalTime, java.time.format.DateTimeFormatter?, java.time.Period
No Java 8, após uma longa história de sofrimento dos desenvolvedores com as classes java.util.Date e java.util.Calendar, foi introduzida uma nova API para manipulação de datas e horas.

Vamos entender quais classes e métodos foram incluídos, além de passar pelos detalhes que serão cobrados na prova.

As classes que serão cobradas são:

LocalDate: representa uma data sem hora no formato yyyy-MM-dd (ano-mês-dia).
LocalTime: representa uma hora no formato hh:mm:ss.zzz (hora:minuto:segundo.milissegundo).
LocalDateTime: representa uma data com hora no formato yyyy-MM-dd-HH-mm-ss.zzz (ano-mês-dia-hora-minuto-segundo.milissegundo).
MonthDay: representa um dia e mês, sem o ano.
YearMonth: representa um mês e ano, sem o dia.
Period: representa um período de tempo, em dia, mês e ano.
DateTimeFormatter: classe que possui vários métodos para formatação.
Para utilizar essas classes, é necessário conhecer uma ou outra classe da API de java.time que não estão na lista da seção, sendo que também as veremos aqui.

Todas as classes do pacote java.time são imutáveis, ou seja, após serem instanciadas, seus valores não podem ser alterados, assim como a classe String. Portanto, lembre-se que todos os métodos que parecem modificar os valores das datas retornam novas instâncias com os valores alterados, enquanto o objeto original segue inalterado.

Criando objetos de data
Todas as classes que representam datas têm métodos similares para criação, como nos exemplos a seguir:


LocalTime currentTime = LocalTime.now(); // 09:05:03.244
LocalDate today = LocalDate.now(); // 2014-12-10
LocalDateTime now = LocalDateTime.now(); 
                        // 2014-12-10-09-05-03.244
É possível escolher o fuso horário que será usando na criação das datas, passando como parâmetro para o método now um objeto do tipo ZoneId:


LocalTime time = LocalTime.now(ZoneId.of("America/Chicago")); 
LocalDate date = LocalDate.now(ZoneId.of("America/Sao_Paulo"));
LocalDateTime dateTime = 
    LocalDateTime.now(ZoneId.of("America/Los_Angeles"));
Caso queira representar uma data ou hora específica, usamos o método of. Cada um desses métodos possui versões sobrecarregadas, recebendo mais ou menos valores iniciais. Todos os tipos de datas que contêm meses possuem versões de of, que recebem tanto números inteiros quanto valores do ::enum:: Month.

Por exemplo, podemos criar uma representação do meio-dia:


LocalTime noon = LocalTime.of(12, 0);
Para criar o natal de 2014 e de 2015:


LocalDate christmas2014 = LocalDate.of(2014, 12, 25);
LocalDate christmas2015 = LocalDate.of(2015, Month.DECEMBER, 25);
Podemos representar qualquer natal:


MonthDay someChristmas = MonthDay.of(Month.DECEMBER, 31);
Ainda com o método of, podemos criar um momento exato no tempo:


LocalDateTime someDate = 
            LocalDateTime.of(2017, Month.JANUARY, 25, 13, 45);
Ou ainda passar um dia e somente adicionar o horário:


LocalDate christmas2014 = LocalDate.of(2014, 12, 25);
LocalDateTime christmasAtNoon = 
    LocalDateTime.of(christmas2014, meioDia);
Passar um valor inválido para qualquer um dos campos (mês 13, por exemplo) lançará um DateTimeException.

Manipulando datas
Uma das decisões de ::design:: que guia a nova API de datas é a padronização dos nomes de métodos que têm o mesmo comportamento. Os nomes mais comuns são:

get: obtém o valor de algo
is: verifica se algo é verdadeiro
with: lembra um ::setter::, mas retorna um novo objeto com o valor alterado
plus: soma alguma unidade ao objeto, retorna um novo objeto com o valor alterado
minus: subtrai alguma unidade do objeto, retorna um novo objeto com o valor alterado
to: converte um objeto de um tipo para outro
at: combina um objeto com outro
Veremos agora esses métodos na prática.

Extraindo partes de uma data
Para obter alguma porção de uma data, podemos usar os métodos precedidos por get:


LocalDateTime now = LocalDateTime.of(2014,12,15,13,0);
System.out.println(now.getDayOfMonth()); // 15
System.out.println(now.getDayOfYear());  // 349
System.out.println(now.getHour());       // 13
System.out.println(now.getMinute());     // 0
System.out.println(now.getYear());       // 2014
System.out.println(now.getDayOfWeek());  // MONDAY
System.out.println(now.getMonthValue()); // 12
System.out.println(now.getMonth());      // DECEMBER
Além desses métodos, temos um método get(), que recebe como parâmetro uma implementação da interface TemporalField, geralmente ChronoField, e retorna um inteiro. Note que como estamos falando de um campo que será retornado. Usamos ChronoField, um campo de tempo cujo valor queremos saber:


LocalDateTime now = LocalDateTime.of(2014,12,15,13,0);
// 15
System.out.println(now.get(ChronoField.DAY_OF_MONTH));  
// 349 
System.out.println(now.get(ChronoField.DAY_OF_YEAR));
// 13    
System.out.println(now.get(ChronoField.HOUR_OF_DAY));  
// 0  
System.out.println(now.get(ChronoField.MINUTE_OF_HOUR));
// 2014
System.out.println(now.get(ChronoField.YEAR));   
// 1 (MONDAY)        
System.out.println(now.get(ChronoField.DAY_OF_WEEK));    
// 12
System.out.println(now.get(ChronoField.MONTH_OF_YEAR));
Nem todas as classes possuem todos os métodos. Por exemplo, objetos do tipo LocalDate não possuem a parte de horas, logo não há métodos como getHour. É necessário ficar atento ao tipo do objeto e a qual método está sendo chamado:


LocalDate d = LocalDate.now();
d.getHour(); //compile error, method not found.
Comparações entre datas
Usamos os métodos que começam com is para realizar comparações entre as datas:


MonthDay day1 = MonthDay.of(1, 1); //01/jan
MonthDay day2 = MonthDay.of(1, 2); //02/jan

System.out.println(day1.isAfter(day2)); //false
System.out.println(day1.isBefore(day2)); //true
Além de métodos de comparação, também existem aqueles para indicar se alguma porção da data é suportada pelo objeto:


LocalDate aprilFools = LocalDate.of(2015, 4, 1);
LocalDate foolsDay = LocalDate.of(2015, 4, 1);
// são equals?
System.out.println(aprilFools.isEqual(foolsDay)); //true
// este objeto suporta dias?
System.out.println(aprilFools.isSupported(
    ChronoField.DAY_OF_MONTH)); //true
// este objeto suporta horas?
System.out.println(aprilFools.isSupported(
    ChronoField.HOUR_OF_DAY)); //false
// posso fazer operações com dias?
System.out.println(aprilFools.isSupported(ChronoUnit.DAYS)); 
//true
// posso fazer operações com horas?
System.out.println(aprilFools.isSupported(ChronoUnit.HOURS)); 
//false
Alterando as datas
Todos os objetos da nova API de datas são imutáveis, ou seja, não podem ter o seu valor alterado após a criação. Mas existem alguns que podem ser utilizados para obter versões modificadas destes objetos. Vamos começar com o método with, que é como um ::setter::, mas retornando um novo objeto em vez de alterar o valor do objeto atual:


LocalDate d = LocalDate.of(2015, 4, 1); //2014-04-01

d = d.withDayOfMonth(15).withMonth(3); //chaining
System.out.println(d); //2015-03-15
Cada método with chamado retorna um novo objeto, com o valor modificado. O objeto original nunca tem seu valor alterado:


LocalDate d = LocalDate.of(2013, 9, 7);
System.out.println(d); // 2013-09-07
d.withMonth(12);
System.out.println(d); // 2013-09-07
Lembre se que só é possível manipular partes da data em objetos que têm estas partes. O exemplo a seguir não compila pois "LocalTime does not have a day of month field".


LocalTime d = LocalTime.now();
d.withDayOfMonth(15); // compile error
Caso o objetivo seja incrementar ou decrementar alguma parte da data, temos os métodos plus e minus:


LocalDate d = LocalDate.of(2013, 9, 7);
d = d.plusDays(1).plusMonths(3).minusYears(2);
System.out.println(d); // 2011-12-08
Podemos adicionar os mesmos três meses usando uma ENUM de unidade de tempo. Cuidado que não estamos falando para alterar o campo ChronoField.WEEK. Isso seria errado, pois não queremos alterar um campo de semana, ou mesmo de dia. Queremos somar uma unidade de tempo, isto é, a API tem que se virar sozinha para adicionar os dias, meses etc. de acordo com o que nós pedirmos, mesmo se for ano bissexto etc. Portanto, não falamos o campo que desejamos alterar mas, sim, a unidade, ChronoUnit:


LocalDate d = LocalDate.of(2013, 9, 7);
d = d.plusWeeks(3).minus(3, ChronoUnit.WEEKS);
System.out.println(d); // 2011-12-08
Para fixar se é ChronoField ou ChronoUnit, lembre-se que você deseja saber (get) o valor de um campo, então ChronoField, .DAY para o dia específico. Caso você deseje adicionar dias, para adicionar N dias usa-se ChronoUnit.DAYS (plural).

Caso você tente manipular uma data usando uma unidade não suportada, será lançada a exception UnsupportedTemporalTypeException:


LocalDate d = LocalDate.of(2013, 9, 7);
                        // UnsupportedTemporalTypeException
                        //LocalDate não suporta horas!
d = d.plus(3, ChronoUnit.HOURS); 
System.out.println(d);
A classe MonthYear
Atenção, a classe MonthYear não possui nenhum método para somar ou subtrair unidades de tempo, logo, ela não tem nenhum método plus ou minus, e também não possui um método isSupported que receba ChronoUnit.

Convertendo entre os diversos tipos de datas
A classe LocalDateTime possui métodos para converter esta data/hora em objetos que só possuem a data (LocalDate) ou que só possuem a hora (LocalTime):


LocalDateTime now = LocalDateTime.now();
LocalDate dateNow = now.toLocalDate(); // de DateTime para Date
LocalTime timeNow = now.toLocalTime(); // de DateTime para Time
As classes também possuem métodos para combinar suas partes e criar um novo objeto modificado:


LocalDateTime now = LocalDateTime.now();
LocalDate dateNow = now.toLocalDate(); // de DateTime para Date
LocalTime timeNow = now.toLocalTime(); // de DateTime para Time

// de Date para DateTime
LocalDateTime nowAtTime1 = dateNow.atTime(timeNow); 
// de Time para DateTime
LocalDateTime nowAtTime2 = timeNow.atDate(dateNow);
Trabalhando com a API legada
Para tornar a API legada compatível com a API nova, foram introduzidos vários métodos nas antigas classes java.util.Date e java.util.Calendar.

O exemplo a seguir converte uma java.util.Date em LocalDateTime usando a timezone padrão do sistema:


Date d = new Date();
Instant i = d.toInstant();
LocalDateTime ldt1 = 
    LocalDateTime.ofInstant(i, ZoneId.systemDefault());
O próximo exemplo transforma um Calendar pelo mesmo processo:


Calendar c = Calendar.getInstance();
Instant i = c.toInstant();
LocalDateTime ldt2 = LocalDateTime.ofInstant(i, 
                                        ZoneId.systemDefault());
Repare que para fazer a conversão usamos como intermediário a classe Instant, que representa o número de milissegundos desde 01/01/1970. Também podemos usar essa classe para fazer o caminho de volta:


Date d = new Date();
Instant i = d.toInstant();
LocalDateTime ldt1 = 
    LocalDateTime.ofInstant(i, ZoneId.systemDefault());

Instant instant = ldt1.toInstant(ZoneOffset.UTC);
Date date = Date.from(instant);
Cálculos de intervalo de tempo com datas
Quando necessitamos realizar algum tipo de cálculo envolvendo duas datas, podemos usar as classes Duration, Period e o método between da classe ChronoUnit:

Duration é a classe de mais baixo nível, usada para manipular objetos do tipo Instant. O exemplo a seguir soma 10 segundos ao instante atual:


Instant now = Instant.now(); // agora
Duration tenSeconds = Duration.ofSeconds(10); // 10 segundos
Instant t = now.plus(tenSeconds); // agora mais 10 segundos
O próximo exemplo mostra como pegar o intervalo em segundos entre dois instantes:


Instant t1 = Instant.EPOCH; // 01/01/1970 00:00:00
Instant t2 = Instant.now();
long secondsSinceEpoch = Duration.between(t1, t2).getSeconds();
Note que Duration só tem a opção de getSeconds; não existem métodos do tipo getDays etc.

ChronoUnit é uma das classes mais versáteis, pois permite ver a diferença entre duas datas em várias unidades de tempo:


LocalDate birthday = LocalDate.of(1983, 7, 22);
LocalDate base = LocalDate.of(2014, 12, 25);

// 31 anos no total
System.out.println(ChronoUnit.YEARS.between(birthday, base)); 
// 377 meses no total
System.out.println(ChronoUnit.MONTHS.between(birthday, base)); 
// 11479 dias no total
System.out.println(ChronoUnit.DAYS.between(birthday, base));
Já a classe Period pode ser usada para fazer cálculos de intervalos, quebrando as unidades de tempo do maior para o menor. Vamos tentar calcular a idade de uma pessoa:


LocalDate birthday = LocalDate.of(1983, 7, 22);
LocalDate base = LocalDate.of(2014, 12, 25);

Period lifeTime = Period.between(birthday, base);

System.out.println(lifeTime.getYears()); // 31 anos
System.out.println(lifeTime.getMonths()); // 5 meses
System.out.println(lifeTime.getDays()); // 3 dias
Formatando e convertendo em texto
Para formatar a impressão de nossas datas, usamos a classe DateTimeFormatter, do pacote java.time.format. Ele segue o mesmo padrão da clássica SimpleDateFormat.


LocalDate birthday = LocalDate.of(1983, 7, 22);
DateTimeFormatter formatter = 
    DateTimeFormatter.ofPattern("yyyy MM dd");
System.out.println(formatter.format(birthday)); // 1983 07 22
Também podemos passar o formatador como parâmetro para o método format dos objetos de data:


LocalDate birthday = LocalDate.of(1983, 7, 22);
DateTimeFormatter formatter =
    DateTimeFormatter.ofPattern("yyyy MM dd");
System.out.println(birthday.format(formatter)); // 1983 07 22
Já para transformar um texto em uma data, usamos o DateTimeFormater juntamente com o método parse da classe que desejamos instanciar:


DateTimeFormatter formatter = 
    DateTimeFormatter.ofPattern("dd/MM/yyyy");
LocalDate d = LocalDate.parse("23/04/1986",formatter);
System.out.println(formatter.format(d)); // 23/04/1986
Caso usemos algum caractere não suportado ou passemos uma data no formato inválido, será lançada uma DateTimeParseException:


DateTimeFormatter formatter = 
    DateTimeFormatter.ofPattern("dd/MM/yyyy");
LocalDate d = 
    LocalDate.parse("23/15/1986",formatter); 
    // throws DateTimeParseException
System.out.println(formatter.format(d)); // 23/04/1986
exercícios
TIRAR DÚVIDA
