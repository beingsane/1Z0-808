#Describe inheritance and its benefits
02
Implementando Herança
PRÓXIMA ATIVIDADE

Em Java, podemos usar herança simples entre classes com o extends. A nomenclatura usada é de classe mãe (parent class) e classe filha (child class), ou superclasse e subclasse.

Herança entre classes permite que um código seja reaproveitado, de maneira que a classe filha reutilize o código da parte mãe, preocupando-se principalmente em sua especialização. A filha especializa a classe mais genérica. Herança em Java pode ser entre classes, reaproveitando membros, ou herança de uma interface, com a qual reaproveitamos interfaces de métodos.


class Mae {
}
class Filha extends Mae {
}
class Neta extends Filha {
}
Vale lembrar que toda classe que não define de quem está herdando herda de Object:


class Explicito extends Object {
}
class Implicito {
    // extends Object por padrão
}
class FilhoDeImplicito extends Implicito{
    // também herda de Object, indiretamente
}
Mas não podemos herdar de duas classes:


class Simples1 {}
class Simples2 {}
class Complexa extends Simples1, Simples2 {
    // não compila
}
Para podermos herdar de uma classe, a classe mãe precisa ser visível pela classe filha e pelo menos um de seus construtores também:


class Pai {
    Pai(int x) {
    }
}
class Filho1 extends Pai{
    // não compila pois o construtor padrão chama super() 
    // e o Pai não tem construtor vazio
}
class Filho2 extends Pai{
    Filho2() {
        super(15); //compila
    }
}
Além disso, a classe mãe não pode ser final:


final class Pai {
}
class Filho extends Pai {
    // não compila, Pai é final
}
class Mae {
}
final class Filha extends Mae {
    // uma classe final pode estender de alguém, compila
}
Herança de métodos e atributos
Todos os métodos e atributos de uma classe mãe são herdados (independente das visibilidades).


class X {
    int x;
    public void y() {
    }
}
class Y {
    // tenho um x, e o método y
}
Dependendo da visibilidade e das classes envolvidas, a classe filha não consegue enxergar o membro herdado. No exemplo a seguir, herdamos o atributo mas não o enxergamos diretamente.


class X {
    private int x;

    public void setX(int x) {
        this.x = x;
    }

    public int getX() {
        return x;
    }
}

class Y extends X {
    public void metodo () {
        this.x = 5; // não compila: "x has private access in X"

        this.setX(10); // compila e altero o x herdado mas 
                       // não visível
    }
}
Métodos estáticos e herança
Não existe herança de métodos estáticos. Mas quando herdamos de uma classe com métodos estáticos, podemos chamar o método da classe mãe usando o nome da filha (embora não seja uma boa prática):


    class W {
        static void metodo() {
        }
    }

    class  Z extends W {
    }

    class Teste {
        public static void main(String[] args) {
            Z.metodo(); // melhor seria escrever W.metodo()
        }
    }

class W {
    public static void metodo() {
        System.out.println("w");
    }
}
class Z extends W {
    public static void metodo() {

        // não existe super em contexto estático, não compila
        super.metodo(); 

    }
}
Por não existir herança, o modificador abstract não é aceito em métodos estáticos.

Podemos até escrever na classe filha um método estático de mesmo nome, mas isso não é sobrescrita (alguns chamam de redefinição):


class W {
    public static void metodo() {
        System.out.println("w");
    }
}
class Z extends W {
    public static void metodo() {
        System.out.println("z");
    }
}
public class Teste {
    public static void main(String[] args) {
        System.out.println(W.metodo()); // w
        System.out.println(Z.metodo()); // z
    }
}
Na verdade você até segue as regras de sobrescrita de método (visibilidade e retorno), mas no polimorfismo ele não funciona como métodos normais. Ele simplesmente funciona com o tipo da variável em tempo de compilação e não o tipo do objeto em tempo de execução:


public class Teste {
    public static void main(String[] args) {
        W w = new W();
        w.metodo(); // w

        Z z = new Z();
        z.metodo(); // z

        W zPolimorfadoComoW = z;
        zPolimorfadoComoW.metodo();
        // este último imprime w,
        // pois o binding é feito em compilação:
        // zPolimorfadoComoW.metodo é uma referencia 
        // em compilação para W
    }
}
Construtores e herança
Não existe herança de construtores. O que existe é a classe filha chamar o construtor da mãe.

Sobrescrita de atributos
Não existe sobrescrita de atributos. Podemos, sim, ter um atributo na classe filha com mesmo nome da mãe, mas não chamamos de sobrescrita. Nesses casos, o objeto vai ter 2 atributos diferentes, um da mãe (acessível com super) e um na filha (acessível com this).

Object
Em Java, toda classe é obrigada a usar a herança. Quando não escrevemos extends explicitamente, estamos herdando de java.lang.Object automaticamente.

Isso quer dizer que todo objeto em Java é um Object e, portanto, herda todos os métodos da classe Object (por isso esses são muito importantes).

Há vários métodos em Object, que veremos ao longo do curso, mas o mais simples talvez seja o toString, que podemos sobrescrever em nossas classes para devolver alguma String que represente o objeto:


class Carro {
    String cor;

    public String toString() {
        return "Um carro de cor " + this.cor;
    }
}
Temos que lembrar que o toString é chamado automaticamente para nós quando usamos o objeto no contexto de String:


    Carro c = new Carro();
    c.cor = "Verde";

    System.out.println(c); // chama toString

    String s = "Mensagem: " + c; // chama toString
    System.out.println(s);
TIRAR DÚVIDA
#Develop code that makes use of polymorphism; develop code that overrides methods; differentiate between the type of a reference and the type of an object
Desenvolva código que mostra o uso de polimorfismo
PRÓXIMA ATIVIDADE

Reescrita ou sobrescrita é a maneira como uma subclasse pode redefinir o comportamento de um método que foi herdado de uma das suas superclasses (direta ou indiretamente).


class Veiculo {
    public void liga() {
        System.out.println("Veiculo está sendo ligado!");
    }
}

class Carro extends Veiculo {
    public void liga() {
        System.out.println("Carro está sendo ligado!");
    }
}
Agora considere:


public class Teste{
    public static void main(String [] args){
        Veiculo v = new Carro();
        v.liga();
    }
}
O método chamado aqui será o da classe Carro, independente de a referência ser do tipo Veiculo (o que importa é o objeto).

Qual método será executado é descoberto em tempo de execução (a assinatura é decidida em tempo de compilação!), isso é a chamada virtual de método (virtual method invocation).

Para reescrever um método, é necessário:

exatamente o mesmo nome;
os parâmetros têm que ser iguais em tipo e ordem (nomes podem mudar);
retorno do método deve ser igual ou mais específico que o da mãe;
visibilidade deve ser igual ou maior que o da mãe;
exceptions lançadas devem ser iguais ou menos que na mãe;
método na mãe não pode ser final.
Se essas regras não forem respeitadas, pode haver um erro de compilação, ou o método declarado não será considerado uma reescrita do método.

A regra sobre visibilidade é: um método reescrito só pode ter visibilidade maior ou igual à do método que está sendo reescrito. (Essa não é uma regra mágica! Faz todo o sentido; pense um pouco sobre o que poderia acontecer se essa regra não existisse).

O código a seguir não compila, pois ligar é público na classe mãe, então só pode ser reescrito com visibilidade pública:


class Veiculo {
    public void liga() {
        System.out.println("Veiculo esta sendo ligado!");
    }
}

class Carro extends Veiculo {
    protected void liga() {
        System.out.println("Carro esta sendo ligado!");
    }
}
Muito cuidado com interfaces, pois a definição de um método é, por padrão, public e o exercício pode apresentar uma pegadinha de compilação:


interface A {
    void a();
}
class B implements A {
    void a() {
        // não compila, o método deveria ser público
    }
}
class C implements A {
    public void a() {
        // compila
    }
}
Estranhamente, um método sobrescrito pode ser abstrato, dizendo para o compilador que quem herdar dessa classe terá que sobrescrever o método original:


class A {
    void a() {
    }
}
abstract class B extends A {
    abstract void a(); // sobrescrevendo como abstrato
}

class C extends B{
    // não compila, não redefiniu a
}

class D extends B{
    void a() {
        // compila pois redefiniu a
    }
}
Sobre o retorno covariante: permite que a classe filha tenha um retorno igual ou mais específico polimorficamente (um subtipo).

Cuidado! O retorno covariante não vale para tipos primitivos. Um exemplo de retorno covariante:


class A {
    List<String> metodo () {
        // devolve lista
    }
}

class B extends A {
    ArrayList<String> metodo() {
        // devolve array list
    }
}
Outra regra importante sobre reescrita é a assinatura em relação ao lançamento de exceções (throws). Um método reescrito só pode lançar as mesmas exceções checked ou menos que o métodos que está sendo reescrito (quanto às unchecked, não há regras e sempre podemos lançar quantas quisermos).


import java.sql.SQLException;
import java.io.IOException;

class A {
    public void metodo () throws SQLException, IOException {
    }
}

class B extends A {
    public void metodo () throws IOException {
    }
}
Esse código compila, pois o método na classe B lança menos exceções que na classe mãe, respeitando a regra. Já o código a seguir não compila:


import java.sql.SQLException;
import java.io.IOException;

class A {
    public void metodo () throws SQLException {
    }
}

class B extends A {
    public void metodo () throws IOException {
    }
}
Apesar de ambos os métodos lançarem apenas uma exceção, não é isso que importa, pois elas são diferentes. Outro caso que não compila:


import java.io.IOException;

class A {
    public void metodo () throws IOException {
    }
}

class B extends A {
    public void metodo () throws Exception {
    }
}
Exception é muito mais que IOException.

Repare que, quando dizemos menos exceções que na mãe, isso indica não apenas quantidade, mas também devemos considerar o polimorfismo. Se trocarmos o exemplo anterior, compilamos:


import java.io.IOException;

class A {
    public void metodo () throws Exception {
    }
}

class B extends A {
    public void metodo () throws IOException {
    }
}
Compila, pois IOException é mais específico que Exception na árvore de herança.

Polimorfismo e chamadas de métodos
Imagine as classes:


class Veiculo {
    void liga() {
        System.out.println("ligando o veiculo");
    }
}
class Carro extends Veiculo {
    void liga() {
        System.out.println("ligando o carro");
    }

    void desliga() {
    }
}
Se tivermos um objeto do tipo Carro com uma referência do tipo Carro, ou seja, sem usar polimorfismo, podemos fazer:


Carro c = new Carro();
c.liga(); // ligando o carro
c.desliga();
Conseguimos chamar os dois métodos. E, como estamos trabalhando com sobrescrita, o método liga chamado é o da classe filha Carro.

Mas e se usarmos polimorfismo e a referência para Veiculo?


Veiculo v = new Carro();
v.liga(); // ligando o carro?
v.desliga();
Vamos linha por linha: primeiro, podemos chamar um Carro de Veiculo porque ele é um (compila sem problemas). Podemos também chamar o método liga pois ambas as classes o possuem. Mas o método que será invocado será o da classe filha, o sobrescrito.

Já a chamada ao método desliga não compilará, porque ele não está definido na classe Veiculo. Como a referência é desse tipo, o método (que existe no objeto) não é visível.

A regra é: para saber se um método de um objeto pode ser chamado, olhamos para o tipo da referência em tempo de compilação. Para realmente chamar o método em tempo de execução, devemos olhar para o objeto ao que demos new.

Essa regra faz sentido quando pensamos em um método polimórfico como o seguinte:


void metodo (Veiculo v) {
    v.liga(); // compila
    v.desliga(); // não compila
}
Se passarmos um objeto Carro para o método, teoricamente ambas as chamadas funcionariam, já que a classe possui tanto o liga quanto o desliga.

Mas imagine uma classe Moto que não tem o método desliga. Como Moto é um Veiculo, podemos passar como argumento. O que aconteceria se pudéssemos ter chamado o desliga na referência Veiculo? Alguma coisa estaria errada.

Portanto, a regra geral é que somente podemos acessar os métodos de acordo com o tipo da referência, pois a verificação da existência do método é feita em compilação. Mas qual o método que será invocado, isso será conferido dinamicamente, em execução.

Um ponto muito importante é que o compilador nunca sabe o valor das variáveis depois da linha que as cria. Ou seja, o compilador não sabe se estamos passando um Carro ou uma Moto. O que ele sabe é apenas o tipo da variável; no caso, Veiculo. E como Veiculo não tem o método desliga, o código não pode compilar.

this, super e sobrescrita de métodos
Na ocasião em que um método foi sobrescrito, podemos utilizar as palavras-chave super e this para deixar explícito qual método desejamos invocar:


class A {
    public void metodo() {
        System.out.println("a");
    }
}
class B extends A {
    public void metodo() {
        System.out.println("b");
        super.metodo(); // imprime a
    }

    public void metodo2() {
        metodo(); // imprime b, a
        super.metodo(); // imprime a
    }
}
E se eu invocar o segundo método na primeira classe? Sem o this?


class A{
    public void metodo() {
        System.out.println("a");
        metodo2();
    }
    public void metodo2() {
        System.out.println("metodo 2 do pai");
    }
}
class B extends A {
    public void metodo() {
        System.out.println("b");
        super.metodo();
    }
    public void metodo2() {
        System.out.println("c");
        metodo();
        super.metodo();
    }
    public static void main(String[] args) {
        new B().metodo2();
    }
}
O Java entra em loop infinito, uma vez que o método será invocado no objeto. Então faremos o lookup do metodo2 dinamicamente, encontrando o metodo2 que chama metodo, que chama metodo do pai, que chama novamente metodo2. Note que o lookup dos métodos, o binding dos métodos, é feito em execução mesmo se invocarmos dentro de um próprio objeto. Até mesmo o uso da palavra-chave this não evitaria isso, causando o loop:


class A{
    public void metodo() {
        System.out.println("a");
        this.metodo2();
    }
    public void metodo2() {
        System.out.println("metodo 2 do pai");
    }
}
class B extends A {
    public void metodo() {
        System.out.println("b");
        super.metodo();
    }
    public void metodo2() {
        System.out.println("c");
        metodo();
        super.metodo();
    }
    public static void main(String[] args) {
        new B().metodo2();
    }
}
TIRAR DÚVIDA
#Develop code that makes use of polymorphism; develop code that overrides methods; differentiate between the type of a reference and the type of an object - Parte 1
Diferencie tipo de uma referência e tipo de um objeto
PRÓXIMA ATIVIDADE

Sempre que estendemos alguma classe ou implementamos alguma interface, estamos relacionando nossa classe com a classe mãe ou interface usando um relacionamento chamado de é um.

Se Carro extends Veiculo, dizemos que Carro é um Veiculo. Ou se ArrayList implements List dizemos que ArrayList é um List.

O relacionamento de é um é um dos recursos mais poderosos da orientação a objetos. E é chamado formalmente de polimorfismo.

Polimorfismo é a capacidade que temos de referenciar um objeto de formas diferentes, segundo seus relacionamentos de é um.

Em especial, usamos polimorfismo quando escrevemos:


    Veiculo v = new Carro();
    List l = new ArrayList();
As heranças e implementações vão formando uma árvore que terá sempre como raiz a classe Object. Assim, direta ou indiretamente, todo objeto é um Object.

O polimorfismo pode ser aplicado à passagem de parâmetros (e é aí que está seu grande poder). Imagine as classes:


class Veiculo {}
class Carro extends Veiculo {}
class Moto extends Veiculo {}
class Onibus extends Veiculo {}
class Conversivel extends Carro {}
Se temos um método que recebe Veiculo, podemos passar qualquer um daqueles objetos:


void metodo (Veiculo v) {

}

// .....

metodo(new Carro());
metodo(new Moto());
metodo(new Onibus());
metodo(new Veiculo());
metodo(new Conversivel());
Dessa forma, conseguimos obter um forte reaproveitamento de código.

Repare que, quando usamos polimorfismo, estamos mudando o tipo da referência, mas nunca o tipo do objeto. Em Java, objetos nunca mudam seu tipo, que é aquele onde demos new. O que fazemos é chamar (referenciar) o objeto de várias formas diferentes. Chamar de várias formas.... é o polimorfismo.

Podemos referenciar um objeto pelo seu próprio tipo, por uma de suas classes pai, ou por qualquer interface implementada por ele, direta ou indiretamente:


interface A {}
interface B {}
class C implements A {}
class D extends C implements B {}
public class Teste {
    public static void main(String[] args) {

        // mesmo tipo, compila
        D d = new D();

        // D extends C, todo D é um C, compila
        C c = new D();
        C c2 = d;

        // D implements B, todo D implementa B, compila
        B b = new D(); 
        B b2 = d;

        // D implements A indiretamente, compila
        A a = new D();
        A a2 = a;

        D d2 = new C(); // não, C não é D, não compila

        D d3 = new D();
        C c3 = d3; // compila
        D d4 = c3; // não compila, por mais que o ser humano 
                   // saiba, em execução, nem todo C é um D.
    }
}
E como funciona o acesso às variáveis membro e aos métodos? Se temos uma referência para a classe mãe, não importa o que o valor seja em tempo de execução, o compilador não conhece o tempo de execução, então ele só compila chamadas aos métodos definidos na classe mãe:


class Veiculo {
    public void liga() { }
}
class Carro extends Veiculo{
    public void mudaMarcha() {}    
}

// teste
Veiculo v = new Veiculo();
v.liga(); // compila

Carro c = new Carro(); // ok
c.mudaMarcha(); // compila

Veiculo v2 = c;
v2.liga(); // todo veiculo tem método liga, compila
v2.mudaMarcha(); // não compila, nem todo veiculo tem
Mesmo em casos em que "achamos" que todo veículo tem, se o método não foi definido na classe de referência, o codigo não compila:


abstract class Veiculo {
    public void liga() { }
}
class Carro extends Veiculo{
    public void desliga() { }
}
class Moto extends Veiculo{
    public void desliga() { }
}

Carro c = new Carro(); // ok
c.desliga(); // compila

Veiculo v2 = c;
v2.desliga(); // não compila, Veiculo não tem o método desliga
              // definido
O mesmo valerá para variáveis membro:


class Veiculo {
    int velocidade;
}
class Carro extends Veiculo{
    int marcha;
}

// teste
Veiculo v = new Veiculo();
v.velocidade = 3; // compila

Carro c = new Carro(); // ok
c.marcha = 1; // compila

Veiculo v2 = c;
v2.velocidade = 5; // compila
v2.marcha = 7; // não compila
E temos que cuidar de mais um caso específico: o que acontece se estamos trabalhando com pacotes distintos?

Se o método da classe pai que está sendo sobrescrito é public, os métodos que sobrescrevem devem ser public, então não tem muita graça.

Já se o método da classe pai é protected, os filhos são protected ou public, que também não tem graça, pois o filho - mesmo em outro pacote - já tinha acesso ao método do pai.

Mas o que acontece se o método no pai é private e eu tento sobrescrevê-lo? Ou se o método é default e tento sobrescrevê-lo em outro pacote? O mesmo valerá tanto para private quando para modificador de escopo padrão:


package financeiro;
public class ContaFinanceira extends modelo.Conta {
    void fecha() {
        System.out.println("fechando financeiro");
    }
}

package modelo;
public class Conta {
    void fecha() {
        System.out.println("fechando conta normal");
    }
}
Ao invocar o método fecha através de uma referência para Conta ou ContaFinanceira, o resultado será totalmente diferente:


ContaFinanceira c = new ContaFinanceira();
c.fecha();
Conta d = c;
d.fecha();
O código não compila, dependendo do pacote onde ele está. Como assim? Acontece que o método não foi sobrescrito, a classe filha nem sabe da existência do método (privado ou default) do pai, portanto o que ela fez foi criar um método totalmente novo.

Nesse caso, ao invocarmos o método durante compilação, o binding é feito para o método específico de cada uma delas, uma vez que são métodos totalmente diferentes. Se o código está no pacote de modelo, a chamada ao método fecha de Conta compila e imprimiria normal. Se estivermos no pacote financeiro, a chamada ao ContaFinanceira compila e imprime financeiro.

Lembre-se que os métodos privados terão um efeito equivalente: eles só são vistos internamente à classe onde foram definidos.

TIRAR DÚVIDA
#Determine when casting is necessary
Quando o cast é necessário
PRÓXIMA ATIVIDADE

Às vezes, temos referências de um tipo mas sabemos que lá há um objeto de outro tipo, um mais específico:


public class Teste{
    public static void main(String...args){
        Object[] objetos = new Object[100];

        String s = "certificacao";
        objetos[0] = s;

        String recuperada = objetos[0];
    }
}
O código acima não compila:


Teste.java:3: incompatible types
found   : java.lang.Object
required: java.lang.String
                String recuperada = objetos[0];
                                           ^
1 error
Temos um array de referências para Object. Nem todo Object é uma String, então o compilador não vai deixar você fazer essa conversão. Lembre-se que, em geral, o compilador não conhece os valores das variáveis, apenas seus tipos.

Vamos precisar moldar a referência para que o código compile:


    String recuperada = (String) objetos[0];
A partir de agora, esse código compila. Mas será que roda? Durante a execução, o casting vai ver se aquele objeto é mesmo compatível com o tipo String (no nosso caso é). Se não fosse, ele lançaria uma ClassCastException (exceção unchecked).

Considere as classes:


    class Veiculo {}
    class Moto extends Veiculo {}
    class Carro extends Veiculo {}


E o código:


    Veiculo v = new Carro();
    Moto m = v;
Na primeira linha, usamos polimorfismo para chamar um Carro de Veiculo (é um). Na segunda linha, o que o compilador sabe é que v é do tipo Veiculo. E nem todo Veiculo é uma Moto. Por isso, essa linha não compila.

Mas existem alguns Veiculo que são Moto. Então, o compilador deixa que façamos o casting:


    Veiculo v = new Carro();
    Moto m = (Moto) v;
Com isso, o código compila, mas repare que, em tempo de execução, v aponta para um objeto do tipo Carro. Quando o código for executado, haverá um erro de execução: ClassCastException. Carro não é uma Moto.

Cuidado que, se o casting for totalmente impossível, o compilador já acusará erro:


    Carro c = new Carro();
    Moto m = (Moto) c;
Um Carro nunca poderá ser uma Moto. Então, nem com casting isso compila.

É importante lembrar que quando não precisamos de casting, ele é opcional, portanto todas as linhas a seguir funcionam com ou sem casting:


String guilherme = "guilherme";
String nome = guilherme;
String nome2 = (String) guilherme;
Object nome3 = guilherme;
Object nome4 = (String) guilherme;
Object nome5 = (Object) guilherme;
Regra geral!
Se você está subindo na hierarquia de classes, a autopromoção vai fazer tudo sozinho; e se você estiver descendo, vai precisar de casting. Se não houver um caminho possível, não compila nem com casting.

Na prova, faça sempre os diagramas de hierarquia de tipos que fica extremamente fácil resolver esses castings.

Casting com interfaces
Dado o código a seguir:


    Carro c = new Carro();
    Moto m = (Moto) c;
Quando dizemos que ele não compila, é porque um Carro nunca pode ser uma Moto. Mas como o compilador sabe que isso é impossível mesmo? Existe alguma chance de algum objeto de qualquer tipo ser, ao mesmo tempo, Carro e Moto?


class X extends Moto, Carro { // não compila!

}
A única maneira de isso acontecer seria se Java suportasse herança múltipla; aí escreveríamos uma classe que herdasse de Carro e Moto ao mesmo tempo. Como Java não tem herança múltipla, isso realmente é impossível de acontecer.

Mas e quando fazemos casting com interfaces envolvidas? Apesar de não existir herança múltipla, podemos implementar múltiplas interfaces! Fazer casting para interfaces sempre é possível e vai compilar (há apenas uma exceção a essa regra).

Pegue uma interface qualquer, por exemplo Runnable. O código a seguir compila:


    Carro c = new Carro();
    Runnable r = (Runnable) c;
Um Carro pode ser um Runnable? Sabemos que a classe Carro propriamente não implementa essa interface. Mas existe a possibilidade de existir algum objeto em Java que seja, ao mesmo tempo, Carro e Runnable?

A resposta é sim! E se tivéssemos uma classe CarroRodavel?

class CarroRodavel extends Carro implements Runnable { ... }
O compilador não sabe o valor da variável c nesse exemplo. Ele não sabe que na verdade é uma instância de Carro e não de CarroRodavel. Ele sabe apenas que é do tipo Carro e, pela simples possibilidade de existir um objeto que seja Carro e Runnable, ele deixa o código compilar.

Mas repare que a classe CarroRodavel não existe no diagrama original. Mesmo assim, o código compila! Apenas com a possibilidade de existir uma classe dessa, o compilador já aceita aquele casting, mesmo que uma classe dessas não exista na prática.

Claro que o objeto é do tipo Carro, que não implementa Runnable e, em tempo de execução, vai ocorrer uma ClassCastingException.

E final
Dizemos que o código anterior compila porque há a possibilidade de uma classe como CarroRodavel existir algum dia. Mas será que sempre há essa possibilidade mesmo?

Se a classe Carro for final, é impossível existir uma classe filha dela. E como a própria Carro não implementa Runnable, nesse caso, será impossível fazer o casting para Runnable (o próprio compilador já acusa erro).

Dica
Muitos exercícios são sobre casting de referência. Uma dica é seguir o que é possível, impossível e óbvio.

Se é óbvio que o casting funciona, isso é, se a conversão é sempre verdade, a autopromoção faz sozinha.

Se o casting é possível, mas nem sempre é verdade, o casting compila, mas pode lançar erro em tempo de execução.

Se o casting é impossível, isto é, ele nunca pode dar certo, o código não vai compilar nem com casting.

Em alguns livros, você encontra tabelas complicadas e grandes que o "ajudam" a decidir se o casting compila e roda, mas é muito mais fácil seguir pela lógica.

instanceof
O operador instanceof (a instanceof Classe) devolve true caso a referência a aponte para um objeto compatível (assignable, atribuível) ao tipo Classe.


        Object c = new Carro();
        boolean b1 = c instanceof Carro; // true
        boolean b2 = c instanceof Moto; // false
O instanceof não compila se a referência em questão for obviamente incompatível, por exemplo:


        String s = "a";
        boolean b  = s instanceof java.util.List; // não compila
Detalhe
instanceof é um operador que deve ser usado com extremo cuidado no dia a dia. Em muitos casos, ele indica a fraca modelagem de um sistema, com blocos que parecem "switchs" e poderiam ser trocados por polimorfismo.

TIRAR DÚVIDA
#Use super and this to access objects and constructors
02
Use super e this para acessar objetos e construtores
PRÓXIMA ATIVIDADE

Um construtor pode ser sobrecarregado assim como os métodos, e pode ter qualquer modificador de visibilidade.

O ponto mais importante sobre os construtores é que, para construir um objeto de uma classe filha, obrigatoriamente, precisamos chamar um construtor da classe mãe antes. Sempre, em todos os casos. Para chamar o construtor da mãe, usamos a chamada ao super (passando ou não argumentos):


class Mae {
    public Mae(String msg) {
        System.out.println(msg);
    }
}

class Filha extends Mae {
    public Filha(String nome) {
        super("construindo parte mae");
        System.out.println("construindo parte filha");
    }
}
Mas, na maioria dos casos, não chamamos o construtor da mãe explicitamente. Se nenhum construtor da mãe foi escolhido através da palavra super(...), o compilador coloca automaticamente super(); no começo do nosso construtor, sem nem olhar para a classe mãe.


class Mae {
    public Mae() {
        System.out.println("construindo parte mae");
    }
}

class Filha extends Mae {
    public Filha(String nome) {
        // super() esta implícito!!!
        System.out.println("construindo parte filha");
    }
}
Considerando agora o código:


public class X{
    public static void main(String [] args){
        Filha filha = new Filha("Teste");
    }
}
Vai primeiro imprimir "Construindo parte mae" e só depois "Construindo parte filha".

Uma outra possibilidade, no caso de termos mais de um construtor, é chamarmos outro construtor da própria classe através do this():


class Mae {
    public Mae() {
        System.out.println("construindo parte mae");
    }
}

class Filha extends Mae {
    public Filha() {
        // super() implicito!
        System.out.println("construindo filha parte 1");
    }

    public Filha(String nome) {
        this();
        System.out.println("construindo filha parte 2");
    }
}

public class X{
    public static void main(String [] args){
        Filha filha = new Filha("Teste");
    }
}
Agora vai produzir "Construindo parte mae", "Construindo parte filha parte 1" e "Construindo parte filha parte 2".

Atenção, a chamada do construtor com super ou this só pode aparecer como primeira instrução do construtor. Portanto, só podemos fazer uma chamada desses tipos.


class Filha extends Object {
    public Filha() {
        // super() implicito!
    }

    public Filha(String nome) {
        this();
    }

    public Filha(int idade) {
        super();
        this(); // não compila, ou um ou outro!
    }
    public Filha(long valor) {
        this();
        this(); // não compila, só uma vez!
    }

    public Filha(char caracter) {
        super();
        super(); // não compila, só uma vez!
    }
}
this e variáveis membro
Por vezes, temos variáveis membro com o mesmo nome de variáveis locais. O acesso sempre será a variável local, exceto quando colocamos o this, que indica que a variável membro será acessada. O código a seguir imprimirá 3 e depois 5:


class Teste {
    int i = 5;
    void roda(int i) {
        System.out.println(i);
        System.out.println(this.i);
    }
    public static void main() {
        new Teste().roda(3);
    }
}
No acesso a variáveis membro com o this podem parecer que serão acessados somente valores da classe atual, mas buscam também nas classes da qual ela herda:


class A{
    int i = 5;
}
class Teste extends A{
    void roda(int i) {
        System.out.println(this.i); // imprime 5
    }
    public static void main(String [] args) {
        new Teste().roda(3);
    }
}
Tentar acessar uma variável local com this não compila:


class Teste {
    void roda(int i) {
        System.out.println(this.i); // não há variável membro i
    }
    public static void main(String [] args) {
        new Teste().roda(3);
    }
}
Como mostramos, caso a variável seja escondida por uma variável com mesmo nome em uma classe filha, podemos diferenciar o acesso à variável membro da classe filha ou da pai, explicitando this ou super:


class A{
    int i = 5;
}
class Teste extends A{
    int i = 10;
    void roda(int i) {
        System.out.println(i); // imprime 3
        System.out.println(this.i); // imprime 10
        System.out.println(super.i); // imprime 5
    }
    public static void main(String [] args) {
        new Teste().roda(3);
    }
}
O this é em geral opcional para acessar um método do nosso objeto atual (se ele não foi redefinido, da classe mãe):


class A{
    int i() { return 5; }
}
class Teste extends A{
    void roda() {
        System.out.println(this.i()); // imprime 5
    }
    public static void main(String [] args) {
        new Teste().roda();
    }
}
class Teste2 {
    int i() { return 5; }
    void roda() {
        System.out.println(this.i()); // imprime 5
    }
    public static void main(String [] args) {
        new Teste().roda();
    }
}
this e super em variável membro
E o que acontece quando uma variável membro tem o mesmo nome que a definida na classe que herdamos? Se não definirmos o acesso através de this nem super, o acesso é à variável da classe filha. Se usarmos this é à classe filha novamente e se usarmos super é à classe pai:


class Veiculo {
    double velocidade = 30;
}
class Carro extends Veiculo {
    double velocidade = 50;
    void imprime() {
        System.out.println(velocidade); // 50
        System.out.println(this.velocidade); // 50
        System.out.println(super.velocidade); // 30
    }
}
class Teste {
    public static void main(String[] args) {
        Carro c = new Carro();
        c.imprime();
    }
}
Lembre-se que o binding de uma variável ao tipo é feito em compilação, portanto se tentarmos acessar a variável velocidade fora do Carro através de uma referência a Carro, o valor alterado é o da variável Carro.velocidade:


class Veiculo {
    double velocidade = 30;
}
class Carro extends Veiculo {
    double velocidade = 50;
    void imprime() {
        System.out.println(velocidade); // 1000
        System.out.println(this.velocidade); // 1000
        System.out.println(super.velocidade); // 30
    }
}
class Teste {
    public static void main(String[] args) {
        Carro c = new Carro();
        c.velocidade = 1000;
        c.imprime();
    }
}
E se fizermos o mesmo através de uma referência a Veiculo, alteramos a velocidade do Veiculo:


class Veiculo {
    double velocidade = 30;
}
class Carro extends Veiculo {
    double velocidade = 50;
    void imprime() {
        System.out.println(velocidade); // 50
        System.out.println(this.velocidade); // 50
        System.out.println(super.velocidade); // 1000
    }
}
class Teste {
    public static void main(String[] args) {
        Carro c = new Carro();
        ((Veiculo) c).velocidade = 1000;
        c.imprime();
    }
}
Estático não tem this nem super
Contextos estáticos não possuem nem this nem super, uma vez que o código não é executado dentro de um objeto:


class A{
    int i = 5;
}
class Teste extends A{
    int i = 10;
    public static void main(String [] args) {
        this.i = 5; // this? não compila. código estático
        super.i = 10; // super? não compila. código estático
    }
}
Por fim, uma última restrição: interfaces não podem ter métodos estáticos, não compila (métodos default não são cobrados nesta prova).
#Use super and this to access objects and constructors
02
Use super e this para acessar objetos e construtores
PRÓXIMA ATIVIDADE

Um construtor pode ser sobrecarregado assim como os métodos, e pode ter qualquer modificador de visibilidade.

O ponto mais importante sobre os construtores é que, para construir um objeto de uma classe filha, obrigatoriamente, precisamos chamar um construtor da classe mãe antes. Sempre, em todos os casos. Para chamar o construtor da mãe, usamos a chamada ao super (passando ou não argumentos):


class Mae {
    public Mae(String msg) {
        System.out.println(msg);
    }
}

class Filha extends Mae {
    public Filha(String nome) {
        super("construindo parte mae");
        System.out.println("construindo parte filha");
    }
}
Mas, na maioria dos casos, não chamamos o construtor da mãe explicitamente. Se nenhum construtor da mãe foi escolhido através da palavra super(...), o compilador coloca automaticamente super(); no começo do nosso construtor, sem nem olhar para a classe mãe.


class Mae {
    public Mae() {
        System.out.println("construindo parte mae");
    }
}

class Filha extends Mae {
    public Filha(String nome) {
        // super() esta implícito!!!
        System.out.println("construindo parte filha");
    }
}
Considerando agora o código:


public class X{
    public static void main(String [] args){
        Filha filha = new Filha("Teste");
    }
}
Vai primeiro imprimir "Construindo parte mae" e só depois "Construindo parte filha".

Uma outra possibilidade, no caso de termos mais de um construtor, é chamarmos outro construtor da própria classe através do this():


class Mae {
    public Mae() {
        System.out.println("construindo parte mae");
    }
}

class Filha extends Mae {
    public Filha() {
        // super() implicito!
        System.out.println("construindo filha parte 1");
    }

    public Filha(String nome) {
        this();
        System.out.println("construindo filha parte 2");
    }
}

public class X{
    public static void main(String [] args){
        Filha filha = new Filha("Teste");
    }
}
Agora vai produzir "Construindo parte mae", "Construindo parte filha parte 1" e "Construindo parte filha parte 2".

Atenção, a chamada do construtor com super ou this só pode aparecer como primeira instrução do construtor. Portanto, só podemos fazer uma chamada desses tipos.


class Filha extends Object {
    public Filha() {
        // super() implicito!
    }

    public Filha(String nome) {
        this();
    }

    public Filha(int idade) {
        super();
        this(); // não compila, ou um ou outro!
    }
    public Filha(long valor) {
        this();
        this(); // não compila, só uma vez!
    }

    public Filha(char caracter) {
        super();
        super(); // não compila, só uma vez!
    }
}
this e variáveis membro
Por vezes, temos variáveis membro com o mesmo nome de variáveis locais. O acesso sempre será a variável local, exceto quando colocamos o this, que indica que a variável membro será acessada. O código a seguir imprimirá 3 e depois 5:


class Teste {
    int i = 5;
    void roda(int i) {
        System.out.println(i);
        System.out.println(this.i);
    }
    public static void main() {
        new Teste().roda(3);
    }
}
No acesso a variáveis membro com o this podem parecer que serão acessados somente valores da classe atual, mas buscam também nas classes da qual ela herda:


class A{
    int i = 5;
}
class Teste extends A{
    void roda(int i) {
        System.out.println(this.i); // imprime 5
    }
    public static void main(String [] args) {
        new Teste().roda(3);
    }
}
Tentar acessar uma variável local com this não compila:


class Teste {
    void roda(int i) {
        System.out.println(this.i); // não há variável membro i
    }
    public static void main(String [] args) {
        new Teste().roda(3);
    }
}
Como mostramos, caso a variável seja escondida por uma variável com mesmo nome em uma classe filha, podemos diferenciar o acesso à variável membro da classe filha ou da pai, explicitando this ou super:


class A{
    int i = 5;
}
class Teste extends A{
    int i = 10;
    void roda(int i) {
        System.out.println(i); // imprime 3
        System.out.println(this.i); // imprime 10
        System.out.println(super.i); // imprime 5
    }
    public static void main(String [] args) {
        new Teste().roda(3);
    }
}
O this é em geral opcional para acessar um método do nosso objeto atual (se ele não foi redefinido, da classe mãe):


class A{
    int i() { return 5; }
}
class Teste extends A{
    void roda() {
        System.out.println(this.i()); // imprime 5
    }
    public static void main(String [] args) {
        new Teste().roda();
    }
}
class Teste2 {
    int i() { return 5; }
    void roda() {
        System.out.println(this.i()); // imprime 5
    }
    public static void main(String [] args) {
        new Teste().roda();
    }
}
this e super em variável membro
E o que acontece quando uma variável membro tem o mesmo nome que a definida na classe que herdamos? Se não definirmos o acesso através de this nem super, o acesso é à variável da classe filha. Se usarmos this é à classe filha novamente e se usarmos super é à classe pai:


class Veiculo {
    double velocidade = 30;
}
class Carro extends Veiculo {
    double velocidade = 50;
    void imprime() {
        System.out.println(velocidade); // 50
        System.out.println(this.velocidade); // 50
        System.out.println(super.velocidade); // 30
    }
}
class Teste {
    public static void main(String[] args) {
        Carro c = new Carro();
        c.imprime();
    }
}
Lembre-se que o binding de uma variável ao tipo é feito em compilação, portanto se tentarmos acessar a variável velocidade fora do Carro através de uma referência a Carro, o valor alterado é o da variável Carro.velocidade:


class Veiculo {
    double velocidade = 30;
}
class Carro extends Veiculo {
    double velocidade = 50;
    void imprime() {
        System.out.println(velocidade); // 1000
        System.out.println(this.velocidade); // 1000
        System.out.println(super.velocidade); // 30
    }
}
class Teste {
    public static void main(String[] args) {
        Carro c = new Carro();
        c.velocidade = 1000;
        c.imprime();
    }
}
E se fizermos o mesmo através de uma referência a Veiculo, alteramos a velocidade do Veiculo:


class Veiculo {
    double velocidade = 30;
}
class Carro extends Veiculo {
    double velocidade = 50;
    void imprime() {
        System.out.println(velocidade); // 50
        System.out.println(this.velocidade); // 50
        System.out.println(super.velocidade); // 1000
    }
}
class Teste {
    public static void main(String[] args) {
        Carro c = new Carro();
        ((Veiculo) c).velocidade = 1000;
        c.imprime();
    }
}
Estático não tem this nem super
Contextos estáticos não possuem nem this nem super, uma vez que o código não é executado dentro de um objeto:


class A{
    int i = 5;
}
class Teste extends A{
    int i = 10;
    public static void main(String [] args) {
        this.i = 5; // this? não compila. código estático
        super.i = 10; // super? não compila. código estático
    }
}
Por fim, uma última restrição: interfaces não podem ter métodos estáticos, não compila (métodos default não são cobrados nesta prova).
#Use abstract classes and interfaces
Use classes abstradas e interface.
PRÓXIMA ATIVIDADE

Classes e métodos podem ser abstratos.

Uma classe abstrata pode não ter nenhum método abstrato:


// compila
abstract class SemMetodos {
}
Se uma classe tem um método que é abstrato, ela deve ser declarada como abstrata, ou não compilará.


// não compila, se tem método abstrato, tem que implementar
class ComMetodoAbstrato {
    public abstract void executa();
}
Uma classe abstrata não pode ser instanciada diretamente:


abstract class X{

}

public class Teste{
    public static void main(String[] args) {
        X x = new X();        
    }
}
A classe Teste não compila! Classes abstratas não podem ser instanciadas diretamente:


Teste.java:7: X is abstract; cannot be instantiated
        X x = new X();        
                      ^
1 error
Um método abstrato é um método sem corpo, somente com a definição. Uma classe que tem um ou mais métodos abstratos precisa ser declarada como abstrata.

Não importa se o método foi escrito diretamente ou foi herdado:


abstract class Veiculo {
    public abstract void liga();
}

// compila pois implementou
class Moto extends Veiculo {
    public void liga() {

    }    
}

// compila pois a classe é abstrata, com método herdado 
// abstrato ainda
abstract class QuatroRodas extends Veiculo {
}

// não compila pois a classe não é abstrata, 
// com método herdado abstrato ainda
class SemRodas extends Veiculo {
}
Um método abstrato tem de ser reescrito ou herdado pelas suas filhas concretas.

Agora veja o exemplo a seguir:


abstract class Veiculo {
    public abstract void liga();
}

class Moto extends Veiculo {
    public void liga() {

    }    
}
O método liga foi implementado na classe filha, então ela pode ser concreta. Basta pensar que métodos abstratos herdados são responsabilidades herdadas: você não poderá ser um objeto concreto enquanto tiver responsabilidades a serem tratadas.

Quando herdamos de uma classe abstrata que possui um método abstrato, temos que escolher: ou implementamos o método, ou somos abstratos também e passamos adiante a responsabilidade. Note que a classe pode implementar o método e mesmo assim também ser abstrata.


abstract class Veiculo {
    public abstract void liga();
}

abstract class Moto extends Veiculo {

}

class MotoEspecial extends Moto {
    public void liga() {

    }    
}

// compila: decidi implementar mas mesmo assim
// manter a classe abstrata
abstract class QuatroRodar extends Veiculo {
    public void liga() {
    }
}
Código de uma classe abstrata pode acessar o código da classe concreta, uma vez que ele só será executado quando o objeto for criado:


abstract class X{
    void x() {
        System.out.println(y());
    }
    abstract String y();
}
class Y extends X {
    String y() {
        return "codigo";
    }
}
public class Teste {
    public static void main(String[] args) {
        new Y().x(); // imprime código
    }
}
Interfaces
Uma interface declara métodos que deverão ser implementados pelas classes concretas que queiram ser consideradas como tal. Por padrão, são todos métodos públicos e abstratos.


interface Veiculo {
    void ligar(); 
    // public abstract! Você pode escrever, mas é por padrão 
    // isso.
    public abstract int pegaMarcha();
}
Quando você implementa a interface em uma classe concreta, é preciso implementar todos os métodos. Similarmente, ao herdar uma classe abstrata, a classe concreta deve implementar todos os métodos que não foram implementados ainda:


// compila, todos os métodos implementados
class Carro implements Veiculo {
    public void ligar() {
    }
    public int pegaMarcha() {
        return 0;
    }
}
// não compila, onde está o pegaMarcha?
class Moto implements Veiculo {
    public void ligar() {
    }
}
// não compila, o método pegaMarcha definiu escopo default, 
// quando deveria definir public
class Triciclo implements Veiculo {
    public void ligar() {
    }
    int pegaMarcha() {
        return 0;
    }
}
Valem as mesmas regras de quando você herda de uma classe abstrata: ou você tem todos os métodos reescritos, e aí pode declará-la como concreta, ou então você precisa declará-la como abstrata.


// compila, pois a classe é abstrata
abstract class Moto implements Veiculo {
    public void ligar() {
    }
}
Uma classe pode implementar diversas interfaces:


abstract class MinhaClasse implements Serializable, Runnable {
}
Justamente por isso, a prova vê como um bom uso de interfaces quando você quer herdar de dois lugares mas a herança de classes não permite. Para a prova, essa razão é suficiente, mas na prática existe uma diferença grande entre composição (herança de interfaces não envolve herdar comportamento e variáveis membro) e herdar comportamento e variáveis membro de uma classe mãe. Como a implementação de uma interface nos obriga a escrever todos os métodos, estamos compondo nossa classe de diversas interfaces.

Lembre-se que uma interface pode herdar de outra, inclusive de diversas interfaces:


interface A extends Runnable {}
interface B extends Serializable {}
interface C extends Runnable, Serializable {}
Note que uma interface nunca implementa outra interface:


interface A implements Runnable {} // não compila
Você pode declarar variáveis em uma interface, todas elas serão public final static, isto é, constantes.


interface X {
    int i = 5;  
    // você até pode escrever public static final, mas é sempre
    // assim
}
Uma interface, por sua vez, pode estender outra interface, herdando suas responsabilidades e constantes. Uma interface pode estender mais de uma interface!


interface X extends Runnable, Comparable { }
TIRAR DÚVIDA
