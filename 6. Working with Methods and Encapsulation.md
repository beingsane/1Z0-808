#Create methods with arguments and return values; including overloaded methods
Crie métodos com argumentos e valores de retorno
PRÓXIMA ATIVIDADE

Classes, enums e interfaces podem ter métodos definidos em seus corpos.

Todo método tem uma assinatura (também chamada de interface) e um corpo (somente no caso de métodos não abstratos).

A assinatura do método sempre tem:

um nome seguindo as regras de identificadores;
um tipo de retorno;
um conjunto de parâmetros (pode ser vazio), cada um com seu nome e seu tipo;
um modificador de visibilidade (nem que seja implícito, package-private).
E, ainda na assinatura, podemos ter:

final - em caso de herança, o método não pode ser sobrescrito nas classes filhas;
abstract - obriga as classes filhas a implementarem o método. O método abstrato não pode ter corpo definido;
static - atributos acessados direto na classe, sem instâncias;
synchronized - lock da instância;
native - não cai nesta prova. Permite a implementação do método em código nativo (JNI);
strictfp - não cai nesta prova. Ativa o modo de portabilidade matemática para contas de ponto flutuante.
throws <EXCEPTIONS> - após a lista de parâmetros, podemos indicar quantas exceptions quisermos para o throws.
A ordem dos elementos na assinatura dos métodos é sempre a seguinte, sendo que os modificadores podem aparecer em qualquer ordem: <MODIFICADORES> <TIPO_RETORNO> <NOME> (<PARÂMETROS>) <THROWS_EXCEPTIONS>

Parâmetros
Em Java, usamos parâmetros em métodos e construtores. Definimos uma lista de parâmetros sempre declarando seus tipos e nomes e separando por vírgula:


class Param {
    void teste(int a, int b) {

    }
}

// chamada
p.teste(1, 2);
A declaração das variáveis é feita na declaração dos métodos. A inicialização dos valores é feita por quem chama o método. (Note que, em Java, não é possível ter valores default para parâmetros e todos são obrigatórios, não podemos deixar de passar nenhum).

O único modificador possível de ser marcado em parâmetros é final, para indicar que aquele parâmetro não pode ter seu valor modificado depois da chamada do método (considerado boa prática):


class Param {
    void teste (final int a) {
        a = 10; // não compila
    }
}
Promoção em parâmetros
Temos que saber que nossos parâmetros também estão sujeitos à promoção de primitivos e ao polimorfismo. Por exemplo, a classe a seguir ilustra as duas situações:


class Param {
    void primitivo (double d) {

    }

    void referencia (Object o) {

    }
}
O primeiro método espera um double. Mas se chamarmos passando um int, um float ou qualquer outro tipo compatível, este será promovido a double e a chamada funciona:


    Param p = new Param();
    p.primitivo(10);
    p.primitivo(10L);
    p.primitivo(10F);
    p.primitivo((short) 10);
    p.primitivo((byte) 10);
    p.primitivo('Z');
A mesma coisa ocorre com o método que recebe Object: podemos passar qualquer um que é um Object, ou seja, qualquer objeto:


    Param p = new Param();
    p.referencia(new Carro());
    p.referencia(new Moto());
Retornando valores
Todo método pode retornar um valor ou ser definido como void, quando não devolve nada:


class A {
    int numero() {
        return 5;
    }
    void nada() {
        return;
    }
}
No caso de métodos de tipo de retorno void (nada), podemos omitir a última instrução:


class A {
    void nada() {
        // return; // pois esta linha é opcional
    }
}
Um método desse tipo também pode ter um retorno antecipado:


class A {
    void nada(int i) {
        if(i >= 0) return;
        System.out.println("negativo");
    }
}
Não podemos ter nenhum código que seria executado após um retorno:


class A {
    void nada(int i) {
        if(i >= 0) {
            return;

            // não compila, pois nunca chegará aqui
            System.out.println("era positivo ou zero"); 
        }
        System.out.println("negativo");
    }
}
Todo método que possui um tipo de retorno definido (isto é, diferente de void), deve retornar algo ou jogar uma Exception em cada um dos caminhos de saída possíveis do método, caso contrário o código não compila:


String metodo(int a) {
    if(a > 0) {
        return "positivo";
    } else if(a < 0) {
        return "negativo";
    }
    //não compila, o que acontece se não for nem if nem else if?
}
Lembre-se que isso é feito pelo compilador, então ele não sabe os valores da variável a e se todos os casos foram cobertos:


String metodo(int a) {
    if(a > 0) {
        return "positivo";
    } else if(a <= 0) {
        return "negativo ou zero";
    }
    //não compila, o que acontece se não for nem if nem else if?
    //o compilador não consegue analisar os dois casos
}
Podemos jogar uma exception ou colocar um return:


String metodo(int a) {
    if(a > 0) {
        return "positivo";
    } else if(a < 0) {
        return "negativo";
    }
    return "zero";
}

String metodo2(int a) {
    if(a > 0) {
        return "positivo";
    } else if(a < 0) {
        return "negativo";
    }
    throw new RuntimeException("não quero zero!");
}
Métodos que não retornam nada não podem ter seu resultado atribuído a uma variável:


void metodo() {
    System.out.println("oi");
}
void metodo2() {
    // não compila, o método acima não retorna nada
    int i = metodo(); 
}
Pelo outro lado, mesmo que um método retorne algo, seu retorno pode ser ignorado:


int metodo() {
    System.out.println("oi");
    return 5;
}
void metodo2() {
    int i = metodo(); // i = 5
    // chamei novamente e não retornei nada, sem problemas
    metodo(); 
}
TIRAR DÚVIDA

#Create methods with arguments and return values; including overloaded methods - Parte 2
Crie métodos sobrecarregados
PRÓXIMA ATIVIDADE

Um método pode ter o mesmo nome que outro, desde que a chamada não fique ambígua: os argumentos que são recebidos têm de ser obrigatoriamente diferentes, seja em quantidade ou em tipos.


class Teste {
    public void metodo(int i) {
    }

    protected void metodo(double x) {
    }
}
Já o código a seguir não compila:


class Teste {
    public int metodo() {}
    protected double metodo() {}
}
Nesse exemplo, temos ambiguidade porque o tipo de retorno não é suficiente para distinguir os métodos durante a chamada.

O Java decide qual das assinaturas de método sobrecarregado (overloaded) será utilizada em tempo de compilação.

Métodos sobrecarregados podem ter ou não um retorno diferente e uma visibilidade diferente. Mas eles não podem ter exatamente os mesmos tipos e quantidade de parâmetros. Nesse caso, seria uma sobrescrita de método.

No caso de sobrecarga com tipos que possuem polimorfismo, como em Object ou String, o compilador sempre invoca o método com o tipo mais específico (menos genérico):


public class Teste {
    void metodo(Object o) {
        System.out.println("object");
    }
    void metodo(String s) {
        System.out.println("string");
    }

    public static void main(String[] args) {
        new Teste().metodo("string"); // imprime string
    }
}
Se quisermos forçar a invocação ao método mais genérico, devemos fazer o casting forçado:


public class Teste {
    void metodo(Object o) {
        System.out.println("object");
    }
    void metodo(String s) {
        System.out.println("string");
    }

    public static void main(String[] args) {
        new Teste().metodo((Object)"string"); // imprime object
    }
}
Um exemplo clássico é a troca de ordem, que é vista como sobrecarga, afinal são dois métodos totalmente distintos:


void metodo(String i, double x) {
}
void metodo(double x, String i) {
}
Porém, apesar de compiláveis, às vezes o compilador não sabe qual método deverá chamar. No caso a seguir, os números 2 e 3 podem ser considerados tanto int quanto double, portanto, o compilador fica perdido em qual dos dois métodos invocar, e decide não compilar:


public class Teste {
    void metodo(int i, double x) {
    }
    void metodo(double x, int i) {
    }

    public static void main(String[] args) {
        new Teste().metodo(2, 3);
    }
}
Isso também ocorre com referências, que é diferente do caso com tipo mais específico. Aqui não há tipo mais específico, pois onde um é mais específico, o outro é mais genérico:


public class Xpto {
    void metodo(Object o, String s) {
        System.out.println("object");
    }
    void metodo(String s, Object o) {
        System.out.println("string");
    }

    public static void main(String[] args) {
        new Xpto().metodo("string", "string");
    }
}
Diferente do caso em que o segundo método é mais específico:


class Xpto2 {
    void metodo(Object o, Object o2) {
        System.out.println("object");
    }
    void metodo(String s, String s2) {
        System.out.println("string");
    }

    public static void main(String[] args) {
        new Xpto2().metodo("string", "string"); // imprime string
    }
}
TIRAR DÚVIDA
#Apply the static keyword to methods and fields
Aplique a palavra chave static a métodos e campos
PRÓXIMA ATIVIDADE

O modificador estático diz que determinado atributo ou método pertence à classe, e não a cada objeto. Com isso, você não precisa de uma instância para acessar o atributo, basta o nome da classe.


public class Carro {
    public static int totalDeCarros;
}
E depois, para acessar:


Carro.totalDeCarros = 5;
Um método estático é um método da classe, podendo ser chamado sem uma instância:


public class Carro{
    private static int totalDeCarros;


    public static int getTotalDeCarros() [
        return totalDeCarros;
    }
}

int i = Carro.getTotalDeCarros();
O que não podemos fazer é usar um método/atributo de instância de dentro de um método estático:


public class Carro{
    private static int totalDeCarros;
    private int peso;

    public static int getPeso() {
        return peso;
    }
}
Esse código não compila, pois peso é um atributo de instância. Se alguém chamar esse método, que valor ele retornaria, já que não estamos trabalhando com nenhuma instância de carro em específico?

Repare que a variável estática pode acessar um método estático, e esse método acessar algo ainda não definido e ter um resultado inesperado à primeira vista:


    static int b = getMetodo();
    public static int getMetodo() {
        return a;
    }
    static int a = 15;
O valor de b será 0, e não 15, uma vez que a variável a ainda não foi inicializada e possui seu valor padrão quando da execução do método getMetodo.

Outro caso interessante é que o atributo estático for de um tipo não primitivo, que começa com valores null, pode gerar um comportamento não esperado.

static Integer inicial = 10;
static Integer segunda = inicial + 5; // compila

static Integer outra;
static void inicializa() {
   outra = 10;
}
static Integer naoExecuta = outra + 1;
// compila mas dá exception em runtime, NullPointerException durante a inicializacao dessa linha
Um detalhe importante é que membros estáticos podem ser acessados através de instâncias da classe (além do acesso direto pelo nome da classe).


    Carro c = new Carro();
    int i = c.getTotalDeCarros();
Cuidado com essa sintaxe, que pode levar a acreditar que é um método de instância. É uma sintaxe estranha mas que compila e acessa o método estático normalmente.

Além disso, esteja atento pois, caso uma classe possua um método estático, ela não pode possuir outro método não estático com assinatura que a sobrescreveria (mesmo que em classe mãe/filha):


class A {
    static void a() { // não compila
    }
    void a() { // não compila
    }
}

class B {
    static void a() {
    }
}
class C extends B {
    void a() { // não compila
    }
}
Outro ponto importante a tomar nota é que o ::binding:: do método é feito em compilação, portanto, o método invocado não é detectado em tempo de execução. Leve em consideração:


class A {
    static void metodo() {
        System.out.println("a");
    }
}

class B extends A {
    static void metodo() {
        System.out.println("b");
    }
}
Caso o tipo referenciado de uma variável seja A em tempo de compilação, o método será o da classe A. Se for referenciado como B, será o método da classe B:


        A a= new A();
        a.metodo(); // a

        B b= new B();
        b.metodo(); // b

        A a2 = b;
        a2.metodo(); // a
    }
}
A definição de uma variável estática pode invocar métodos e variáveis estáticas:


class A {
    static int idade = calculaIdade();
    static int calculaIdade() {
        return 18;
    }
}
A palavra-chave static pode ser aplicada a classes aninhadas, mas este tópico não é cobrado nesta primeira certificação.

TIRAR DÚVIDA
#Create and overload constructors; differentiate between default and user defined constructors - Parte 1
02
Crie e sobrecarregue construtores
PRÓXIMA ATIVIDADE

Construtores também podem ser sobrecarregados:


class Teste {
    public Teste() {
    }
    public Teste(int i) {
    }
}
Cuidado com os exemplos de sobrecarga com varargs, como vimos antes, e no caso de herança.

Quando existem dois construtores na mesma classe, um construtor pode chamar o outro através da chamada this. Note que loops não compilam:


class Teste {
    public Teste() {
        System.out.println("construtor simples");
    }
    public Teste(int i) {
        this();
    }
    public Teste(String s) {
        this(s, s);  // não compila, loop
    }
    public Teste(String s, String s2) {
        this(s); // não compila, loop
    }
}
Temos que tomar cuidado com sobrecarga da mesma maneira que tomamos cuidado com sobrecarga de métodos: os construtores invocados seguem as mesmas regras que as de métodos.

Quando um método utiliza varargs, se ele possui uma variação do método sem nenhum argumento e invocarmos sem argumento, ele chamará o método sem argumentos (para manter compatibilidade com versões anteriores do Java):


void desativa(Cliente... clientes) {
    System.out.println("varargs");
}
void desativa() {
    System.out.println("sem argumento");
}
void metodo() {
    desativa(); // imprime sem argumento
}
A instrução this do construtor deve ser sempre a primeira dentro do construtor:


class Teste {
    Teste() {
        String valor = "valor...";
        this(valor); // não compila
    }

    Teste(String s) {
        System.out.println(s);
    }

    public static void main(String[] args) {
        new Teste();
    }
}
Justo por isso não é possível ter duas chamadas a this:


class Teste {
    Teste() {
        this(valor);
        this(valor); // não compila
    }

    Teste(String s) {
        System.out.println(s);
    }

    public static void main(String[] args) {
        new Teste();
    }
}
A instrução this pode envolver instruções:


class Teste {
    Teste() {
        this(valor());
    }

    private static String valor() {
        return "valor...";
    }

    Teste(String s) {
        System.out.println(s);
    }

    public static void main(String[] args) {
        new Teste();
    }
}
A instrução não pode ser um método da própria classe, pois o objeto não foi construído ainda:


class Teste {
    Teste() {
        this(valor()); // valor não é estático, não compila
    }

    private String valor() {
        return "valor...";
    }

    Teste(String s) {
        System.out.println(s);
    }

    public static void main(String[] args) {
        new Teste();
    }
}
TIRAR DÚVIDA

#Create and overload constructors; differentiate between default and user defined constructors - Parte 2
Diferença entre o construtor padrão e construtores definidos pelo usuário
PRÓXIMA ATIVIDADE

Quando não escrevemos um construtor na nossa classe, o compilador nos dá um construtor padrão. Esse construtor, chamado de default não recebe argumentos, tem a mesma visibilidade da classe e tem a chamada a super().

A classe a seguir:


class A {
}
... na verdade, acaba sendo:


class A {
    A() {
        super();
    }
}
Caso você adicione um construtor qualquer, o construtor default deixa de existir:


class A {}
class B {
    B(String s) {}
}
class Teste {
    public static void main(String[] args) {
        new A(); // construtor padrão, compila
        new B(); // não existe mais construtor padrão
        new B("CDC"); // construtor existente
    }
}
Dentro de um construtor você pode acessar e atribuir valores aos atributos, suas variáveis membro:


class Teste {
    int i;
    Teste() {
        i = 15; // agora i vale 15
        System.out.println(i); // 15
    }

    public static void main(String[] args) {
        new Teste();
    }
}
Os valores inicializados com a declaração das variáveis são inicializados antes do construtor, justamente por isso o valor inicial de i é 0, o valor padrão de uma variável int membro:


class Teste {
    int i;
    Teste() {
        System.out.println(i); // vale 0 por padrão
        i = 15; // agora i vale 15
        System.out.println(i); // 15
    }

    public static void main(String[] args) {
        new Teste();
    }
}
Vale lembrar que variáveis membro são inicializadas automaticamente para: numéricas 0, boolean false, referências null.

Cuidado ao acessar métodos cujas variáveis ainda não foram inicializadas no construtor. O exemplo a seguir mostra um caso em que o método de inicialização é invocado antes de setar o valor da variável no construtor, o que causa um NullPointerException.


class A {

    int i = 15;
    String nome;
    int tamanho = tamanhoDoNome();

    A(String nome) {
        this.nome = nome;
    }

    int tamanhoDoNome() {
        return nome.length();
    }

    A() {
    }

}
Mesmo que inicializemos a variável fora do construtor, após a chamada do método pode ocorrer um erro, como no caso a seguir, de um outro NullPointerException:


class A {

    int i = 15;
    String nome;
    int tamanho = tamanhoDoSobrenome();
    String sobrenome = "Silveira";

    A(String nome) {
        this.nome = nome;
    }

    int tamanhoDoSobrenome() {
        return sobrenome.length();
    }

    A() {
    }

}
Mudar a ordem da declaração das variáveis resolve o problema, uma vez que o método é agora invocado após a inicialização da variável sobrenome:


class A {

    int i = 15;
    String nome;
    String sobrenome = "Silveira";
    int tamanho = tamanhoDoSobrenome();

    A(String nome) {
        this.nome = nome;
    }

    int tamanhoDoSobrenome() {
        return sobrenome.length();
    }

    A() {
    }

}
Cuidado ao invocar métodos no construtor e variáveis estarem nulas:


class Teste {
    String nome;
    Teste() {
        testaTamanho(); // NullPointerException
        nome = "aprendendo";
    }

    private void testaTamanho() {
        System.out.println(nome.length());
    }

    public static void main(String[] args) {
        new Teste();
    }
}
E mais cuidado ainda caso isso ocorra por causa de sobrescrita de método, em que também poderemos ter essa Exception:


class Base {
    String nome;
    Base() {
        testa();
        nome = "aprendendo";
    }

    void testa() {
        System.out.println("testa");
    }

}
class Teste extends Base {
    void testa() {
        System.out.println(nome.length());
    }
    public static void main(String[] args) {
        new Teste();
    }
}
Já se o método testa for privado, como o binding da chamada ao método é feito em compilação, o método invocado pelo construtor é o da classe mãe, sem dar a Exception:


class Base {
    String nome;
    Base() {
        testa();
        nome = "aprendendo";
    }

    private void testa() {
        System.out.println("testa");
    }

}
class Teste extends Base {
    void testa() {
        System.out.println(nome.length());
    }
    public static void main(String[] args) {
        new Teste();
    }
}
Você pode entrar em loop infinito, cuidado, StackOverflow:


class Teste {
    Teste() {
        new Teste();
    }
    public static void main(String[] args) {
        new Teste();
    }
}
Construtores podem ser de todos os tipos de modificadores de acesso: private, protected, default e public.

É comum criar um construtor privado e um método estático para criar seu objeto:


class Teste {
    private Teste() {
    }

    public static Teste cria() {
        return new Teste();
    }
}
Tenha muito cuidado com um método com nome do construtor. Se colocar um void na frente, vira um método:


class Teste {
  void Teste() {
    System.out.println("Construindo");
  }

  public static void main(String[] args) {

    new Teste(); 
    // não imprime nada, definimos um método e não o construtor
    new Teste().Teste(); 
    // agora imprime Construindo
  }
}
Existem também blocos de inicialização que não são cobrados na prova.

TIRAR DÚVIDA
#Apply access modifiers

Aplique modificadores de acesso
PRÓXIMA ATIVIDADE

Os modificadores de acesso, ou modificadores de visibilidade, servem para definir quais partes de cada classe (ou se uma classe inteira) estão visíveis para serem utilizadas por outras classes do sistema. Só é permitido usar um único modificador de acesso por vez:


private public int x; // não compila
O Java possui os seguintes modificadores de acesso:

public
protected
Nenhum modificador, chamado de default
private
Classes e interfaces só aceitam os modificadores public ou default.

Membros (construtores, métodos e variáveis) podem receber qualquer um dos quatro modificadores.

Variáveis locais (declaradas dentro do corpo de um método ou construtor) e parâmetros não podem receber nenhum modificador de acesso, mas podem receber outros modificadores.

Top Level Classes e Inner Classes
Classes internas (nested classes ou inner classes) são classes que são declaradas dentro de outras classes. Esse tipo de classe pode receber qualquer modificador de acesso, já que são consideradas membros da classe onde foram declaradas (top level class).

Nesta certificação não são cobradas classes internas, apenas top level classes.

Para entender como os modificadores funcionam, vamos imaginar as seguintes classes:


package forma;

class Forma{
    double lado;
    double getArea(){
        return 0;
    }
}

package forma;

class Quadrado extends Forma{}

package forma.outro;
import forma.*;

class Triangulo extends Forma{}
Public
O modificador public é o menos restritivo de todos. Classes, interfaces e membros marcados com esse modificador podem ser acessados de qualquer componente, em qualquer pacote. Vamos alterar nossa classe Forma, marcando-a e todos seus membros com o modificador public:


package forma;

public class Forma{
    public double lado;
    public double getArea(){
        return 0;
    }
}
Agora vamos fazer um teste:


package forma.outro;
import forma.*;

public class TesteOutroPacote{

    public static void main(String... args){
        Forma f = new Forma(); //acesso a classe forma
        f.lado = 5.5; //acesso ao atributo lado
        f.getArea(); //acesso ao método getArea()
    }
}
Repare que, mesmo nossa classe TesteOutroPacote estando em um pacote diferente da classe Forma, é possível acessar a classe e todos os membros declarados como public.

Protected
Membros definidos com o modificador protected podem ser acessados por classes e interfaces no mesmo pacote, e por qualquer classe que estenda aquela onde o membro foi definido, independente do pacote.

Vamos modificar nossa classe Forma para entendermos melhor:


package forma;

public class Forma{
    protected double lado; // agora protected
    public double getArea(){}
}
Com o modificador protected, nossa classe de testes em outro pacote não compila mais:


package forma.outro;
import forma.*;

public class TesteOutroPacote{

    public static void main(String... args){
        Forma f = new Forma(); 
        f.lado = 5.5; // erro de compilação
        f.getArea(); 
    }
}
Se criarmos uma nova classe de teste no pacote forma, conseguimos acessar novamente o atributo:


package forma;

public class Teste{

    public static void main(String... args){
        Forma f = new Forma(); 
        f.lado = 5.5; // compila normal, mesmo pacote
    }
}
Embora esteja em um pacote diferente, a classe Triangulo consegue acessar o atributo lado, já que ela estende da classe Forma:


package forma.outro;
import forma.*;

class Triangulo extends Forma{

    public void imprimeLado(){
        //Como é uma classe filha, acessa 
        //normalmente os membros protected da classe mãe.
        System.out.println("O Lado é " + lado);
    }
}
Agora repare que, se efetuarmos o casting do objeto atual para uma Forma, não podemos acessar seu lado:


package outro;
import forma.*;

class Triangulo extends Forma{

    public void imprimeLado(){
        // compila
        System.out.println("O Lado é " + lado); 

        // não compila
        System.out.println("O Lado é " + ((Forma) this).lado); 
    }
}
Isso ocorre porque estamos dizendo que queremos acessar a variável membro lado de um objeto através de uma referência para este objeto, e não diretamente. Diretamente seria o uso puro do this ou nada. Nesse caso, após usar o this, usamos um casting, o que deixa o compilador perdido.

Default
Se não definirmos explicitamente qual o modificador de acesso, podemos dizer que aquele membro está usando o modificador default, também chamado de package private. Neste caso, os membros da classe só serão visíveis dentro do mesmo pacote:


package forma;

public class Forma{
    protected double lado; 
    public double getArea(){
        return 0;
    }
    double getPerimetro(){ //default access 
        return 0;
    }
}
O método getPerimetro() só será visível para todas as classes do pacote forma. Nem mesmo a classe Triangulo - que, apesar de herdar de Forma, está em outro pacote - consegue ver o método.


package outro;
import forma.*;

class Triangulo extends Forma{

    public void imprimePerimetro(){
        //Erro de compilação na linha abaixo
        System.out.println("O Perímetro é " + getPerimetro());
    }
}
Palavra-chave %%default%%
Lembre-se! A palavra-chave default é usada para definir a opção padrão em um bloco switch, ou para definir um valor inicial em uma Annotation. Usá-la em uma declaração de classe ou membro é inválido e causa um erro de compilação:


default class Bola{ //ERRO
    default String cor; // ERRO
}
A partir do Java 8, a palavra default também pode ser usada para definir uma implementação inicial de um método.

Mas e se declararmos uma classe com o modificador default? Isso vai fazer com que aquela classe só seja visível dentro do pacote onde foi declarada. Não importa quais modificadores os membros dessa classe tenham, se a própria classe não é visível fora de seu pacote, nenhum de seus membros é visível também.

Veja a classe Quadrado, que está definida com o modificador default:


package forma;

class Quadrado extends Forma{}
Veja o seguinte código, usando a classe TesteOutroPacote. Perceba que não é possível usar a classe Quadrado, mesmo importando todas as classes do pacote forma:


package outro;
import forma.*;

public class TesteOutroPacote{

    public static void main(String... args){
        Quadrado q = new Quadrado(); // erro, esta classe não é
                                     //visível
    }
}
Linha com erro de compilação
Eventualmente, na prova, é perguntado em quais linhas ocorreram os erros de compilação. É bem importante prestar atenção nesse detalhe.

Por exemplo, neste caso, o erro sempre acontecerá quando tentarmos acessar a classe Quadrado, que não é visível fora de seu pacote:


package outro;

//import de todas as classes PÚBLICAS do pacote, nenhum erro
import forma.*; 


public class TesteOutroPacote{

    public static void main(String... args){
        // erro na linha 8, Quadrado não é visível, pois não 
        // é pública
        Quadrado q = new Quadrado(); 
    }
}
O mesmo código pode apresentar erro em uma linha diferente, apenas mudando o import. Repare que o código a seguir dá erro nas duas linhas, tanto do import quanto na tentativa de uso:


package outro;
// erro na linha 3, não podemos importar classes não públicas 
import forma.Quadrado;

public class TesteOutroPacote{

    public static void main(String... args){

        //Erro, pois Quadrado não é acessível.
        Quadrado q = new Quadrado(); 
    }
}
É muito importante testar vários trechos de código, para ver exatamente em quais linhas de código o erro de compilação aparecerá.

Private
private é o mais restritivo de todos os modificadores de acesso. Membros definidos como private só podem ser acessados de dentro da classe e de nenhum outro lugar, independente de pacote ou herança:


package forma;

public class Forma{
    protected double lado;
    public double getArea(){}

    //cor só pode ser acessada dentro da classe Forma,
    //nem as classe Quadrado e Triangulo conseguem acessar
    private String cor;

}
Private e classes aninhadas ou anônimas
Classes aninhadas ou anônimas podem acessar membros privados da classe onde estão contidas. Na certificação tais classes não são cobradas.

Métodos privados e padrão não podem ser sobrescritos. Se uma classe o "sobrescreve", ele simplesmente é um método novo, portanto não podemos dizer que é sobrescrita. Veremos isso mais a fundo na seção sobre sobrescrita.

Resumo das regras de visibilidade
Todos os membros da classe com o modificador de private só podem ser acessados de dentro dela mesma.

Todos os membros da classe sem nenhum modificador de visibilidade, ou seja, com visibilidade package-private, podem ser acessados de dentro da própria classe ou de dentro de qualquer outra classe, interface ou enum do mesmo pacote.

Todos os membros da classe com o modificador protected podem ser acessados:

de dentro da classe, ou de dentro de qualquer outra classe, interface ou enum do mesmo pacote;
de dentro de alguma classe que deriva direta ou indiretamente da classe, independente do pacote. O membro protected só pode ser chamado através da referência this, ou por uma referência que seja dessa classe filha.
Todos os membros da classe com o modificador public podem ser acessados de qualquer lugar da aplicação.

E não podemos ter classes/interfaces/enums top-level como private ou protected.

Uma classe é dita top-level se ela não foi definida dentro de outra classe, interface ou enum. Analogamente, são definidas as interfaces top-level e os enums top-level.

TIRAR DÚVIDA

Apply encapsulation principles to a class
Aplique princípios de encapsulamento a uma classe
PRÓXIMA ATIVIDADE

A assinatura de um método é o que realmente deve importar para o usuário de alguma classe. Segundo os bons princípios do encapsulamento, a implementação dos métodos deve estar encapsulada e não deve fazer diferença para o usuário.

O que é importante em uma classe é o que ela faz e não como ela faz. O que ela faz é definido pelos comportamentos expostos, ou seja, pelos métodos e suas assinaturas.

O conjunto de assinaturas de métodos visíveis de uma classe é chamado de interface de uso. É através dessas operações que os usuários vão se comunicar com os objetos dessa classe.

Mantendo os detalhes de implementação de nossas classes "escondidos", evitamos que mudanças na forma de implementar uma lógica quebre vários pontos de nossa aplicação.

Uma das formas mais simples de começar a encapsular o comportamento de uma classe é escondendo seus atributos. Podemos fazer isso facilmente usando a palavra-chave private:


public class Pessoa{
    private String nome;
}
Caso precisemos acessar um desses atributos a partir de outra classes, teremos que criar um método para liberar o acesso de leitura desse atributo. Seguindo a especificação dos javabeans, esse método seria um getter. Da mesma forma , se precisarmos liberar a escrita de algum atributo, criamos um método setter :


    public class Pessoa{
        private String nome;

        public String getNome() {
            return nome;
        }
        public void setNome(String nome) {
            this.nome = nome;
        }
    }
Com essa abordagem, poderíamos fazer uma validação em nossos métodos, para evitar que nossos atributos fiquem com estado inválido. Por exemplo, podemos verificar se o nome possui pelo menos 3 caracteres:


public class Pessoa{
    private String nome;
    private String sobrenome;

    public String getNome() {
        return nome;
    }
    public void setNome(String nome) {
        if(nome!= null && nome.trim().length() >= 3)
            this.nome = nome;
        else{
            throw new IllegalArgumentException(
             "Nome deve possuir " + "pelo menos 3 caracteres");
        }
    }
}
Encapsulamento é muito mais do que atributos privados e getters e setters . Não é nosso foco aqui discutir boas práticas de programação, e sim o conhecimento necessário para passar na prova. Em questões sobre encapsulamento sempre, fique atento à alternativa que esconde mais detalhes de implementação da classe analisada. A prova pode utilizar tanto o termo encapsulation como information hiding para falar sobre encapsulamento (ou esconder informações).

TIRAR DÚVIDA

#Determine the effect upon object references and primitive values when they are passed  into methods that change the values
Efeito que ocorre com referências a objetos e a tipos primitivos quando passados a outros métodos
PRÓXIMA ATIVIDADE

As informações que queremos enviar para um método devem ser passadas como parâmetro. O domínio de como funciona a passagem de parâmetro é fundamental para a prova de certificação.

O requisito para entender passagem de parâmetro no Java é saber como funciona a pilha de execução e o heap de objetos.

A pilha de execução é o "lugar" onde são empilhados os métodos invocados na mesma ordem em que foram chamados.

O heap é o "lugar" onde são guardados os objetos criados durante a execução.

Considere o exemplo a seguir:


class Teste {
    public static void main(String[] args) {
        int i = 2;
        teste(i);
    }

    private static void teste(int i) {
        for (int j = 0; j < i; j++) {
            new String("j = " + j);
        }
    }
}




A passagem de parâmetros é feita por cópia de valores. Dessa forma, mudanças nos valores das variáveis definidas na lista de parâmetros de um método não afetam variáveis de outros métodos.

Passagem de parâmetros primitivos
Veja o seguinte código:


class Teste {
    public static void main(String[] args) {
        int i = 2;
        teste(i);
        System.out.println(i); 
    }

    static void teste(int i) {
        i = 3;
    }
}
Ao executar a classe Teste, será impresso o valor 2. É necessário perceber que as duas variáveis com o nome i estão em métodos diferentes. Há um i no main() e outro i no teste(). Alterações em uma das variáveis não afetam o valor da outra.

Passagem de parâmetros de referência
Agora veja esta classe:


class Teste {
    public static void main(String[] args) {
        Prova prova = new Prova();
        prova.tempo = 100;
        teste(prova);
        System.out.println(prova.tempo); 
    }

    static void teste(Prova prova) {
        prova.tempo = 210;
    }
}

class Prova {
    double tempo;
}
Esse exemplo é bem interessante e causa muita confusão. O que será impresso na saída, ao executar a classe Teste, é o valor 210. Os dois métodos têm variáveis com o mesmo nome (prova). Essas variáveis são realmente independentes, ou seja, mudar o valor de uma não afeta o valor da outra.

Por outro lado, como são variáveis não primitivas, elas guardam referências e, neste caso, são referências que apontam para o mesmo objeto. Modificações nesse objeto podem ser executadas através de ambas as referências.

Mas se eu trocar a referência, só estou trocando nesta variável local, e não no objeto referenciado, como no exemplo do teste2, em que estamos trocando somente a referência local e não o outro:


class Prova {
    int tempo;
}
class TestaReferenciaEPrimitivo {
    public static void main(String[] args) {
        Prova prova = new Prova();
        prova.tempo = 100;
        teste(prova);
        System.out.println(prova.tempo);

        teste2(prova);
        System.out.println(prova.tempo);


        int i = 2;
        i = teste(i);
        System.out.println(i);
    }
    static void teste2(Prova prova) {
        prova = new Prova();
        prova.tempo = 520;
    }

    static void teste(Prova prova) {
        prova.tempo = 210;
    }

    static int teste(int i) {
        i = 5;
        System.out.println(i);
        return i;
    }
}
TIRAR DÚVIDA

