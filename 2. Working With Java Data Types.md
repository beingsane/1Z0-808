#Declare and initialize variables (including casting of primitive data types)
 02 Declarar e inicializar variáveis
PRÓXIMA ATIVIDADE


// Declaração
int idade;

System.out.println(idade); // erro de compilação

// Declaração
int idade;

// Inicialização explícita de uma variável
idade = 10;

// Utilização da variável
System.out.println(idade); // ok
Podemos declarar e iniciar a variável na mesma instrução:


// Declaração e inicialização explícita na mesma linha
double pi = 3.14;
Se eu tenho um if, a inicialização deve ser feita em todos os caminhos possíveis:


void metodo(int a) {
    double x;
    if(a > 1) {
        x = 6;
    }
    System.out.println(x); // talvez x não tenha sido 
                           // inicializado, portanto não compila
}
Quando a variável é membro de uma classe, ela é iniciada implicitamente junto com o objeto com um valor default:


class Prova {
     double tempo;
}

// Implicitamente, na criação de um objeto Prova, 
// o atributo tempo é iniciado com 0
Prova prova = new Prova();

// Utilização do atributo tempo
System.out.println(prova.tempo);
Outro momento em que ocorre a inicialização implícita é na criação de arrays:


    int[] numeros = new int[10];
    System.out.println(numeros[0]); // imprime 0
Quando iniciadas implicitamente, os valores default para as variáveis são:

primitivos numéricos inteiros - 0
primitivos numéricos com ponto flutuante - 0.0
boolean - false
char - vazio, equivalente a 0
referências - null
Os tipos das variáveis do Java podem ser classificados em duas categorias: primitivos e não primitivos (referências).

Tipos primitivos
Todos os tipos primitivos do Java já estão definidos e não é possível criar novos tipos primitivos. São oito os tipos primitivos do Java: byte, short, char, int, long, float, double e boolean.

O boolean é o único primitivo não numérico. Todos os demais armazenam números: double e float são ponto flutuante, e os demais, todos inteiros (incluindo char). Apesar de representar um caractere, o tipo char armazena seu valor como um número positivo. Em Java, não é possível declarar variáveis com ou sem sinal (unsigned), todos os números (exceto char) podem ser positivos e negativos.

Cada tipo primitivo abrange um conjunto de valores. Por exemplo, o tipo byte abrange os números inteiros de -128 até 127. Isso depende do tamanho em bytes do tipo sendo usado.

Os tipos inteiros têm os seguintes tamanhos:

byte - 1 byte (8 bits, de -128 a 127);
short - 2 bytes (16 bits, de –32.768 a 32.767);
char - 2 bytes (só positivo), (16 bits, de 0 a 65.535);
int - 4 bytes (32 bits, de –2.147.483.648 a 2.147.483.647);
long - 8 bytes (64 bits, de –9.223.372.036.854.775.808 a 9.223.372.036.854.775.807).
Decorar o tamanho dos primitivos para prova
Não há a necessidade de decorar o intervalo e tamanho de todos os tipos de primitivos para a prova. O único intervalo cobrado é o do byte (-128 a 127).

É importante também saber que o char, apesar de ter o mesmo tamanho de um short, não consegue armazenar todos os números que cabem em um short, já que o char só armazena números positivos.

Para saber mais: calculando o intervalo de valores
Dado o número de bits N do tipo primitivo inteiro, para saber os valores que ele aceita usamos a seguinte conta:

-2^(n-1) a 2^(n-1) -1
O char, por ser apenas positivo, tem intervalo:

0 a 2^(16) -1
Os tipos ponto flutuante têm os seguintes tamanhos em notação científica:

float - 4 bytes (32 bits, de +/–1.4 10 ^ 45 a +/–3.4028235 10 ^ 38);
double - 8 bytes (64 bits, de +/–4.9 10 ^ 324 a +/–1.7976931348623157 10 ^ 308).
Todos os números de ponto flutuante também podem assumir os seguintes valores:

+/– infinity
+/- 0
NaN (Not a Number)
Literais
Na codificação, muitas vezes o programador coloca os valores das variáveis diretamente no código-fonte. Quando isso ocorre, dizemos que o valor foi literalmente escrito no código, ou seja, é um valor literal.

Todos os valores primitivos maiores que int podem ser expressos literalmente. Por outro lado, as referências (valores não primitivos) não podem ser expressas de maneira literal (não conseguimos colocar direto os endereços de memória dos objetos).

Ao inicializar uma variável, podemos explicitar que queremos que ela seja do tipo double ou long usando a letra específica:


        // compila pois 737821237891232 é um double válido
        System.out.println(737821237891232d);

        // compila pois 737821237891232 é um long válido
        System.out.println(737821237891232l);

        // nao compila pois 737821237891232 é um valor maior que
        // o int aceita
        System.out.println(737821237891232);
Da mesma maneira, o compilador é um pouco esperto e percebe se você tenta quebrar o limite de um int muito facilmente:


        // compila pois 737821237891232l é um long válido
        long l = 737821237891232l;

        // não compila pois o compilador não é bobo assim
        int i = l;


// booleanos
System.out.println(true); // booleano verdadeiro
System.out.println(false); // booleano falso

// números simples são considerados inteiros
System.out.println(1); // int

// números com casa decimal são considerados double.
// Também podemos colocar uma letra "D" ou "d" no final
System.out.println(1.0); //double
System.out.println(1.0D); //double

// números inteiros com a letra "L" ou "l" 
// no final são considerados long.
System.out.println(1L); //long

// números com casa decimal com a letra "F" ou "f" 
// no final são considerados float.
System.out.println(1.0F); //float
Bases diferentes
No caso dos números inteiros, podemos declarar usando bases diferentes. O Java suporta a base decimal e mais as bases octal, hexadecimal e binária.

Um número na base octal tem que começar com um zero à esquerda e pode usar apenas os algarismos de 0 a 7:


int i = 0761; // base octal

System.out.println(i); // saída: 497
E na hexadecimal, começa com 0x ou 0X e usa os algarismos de 0 a 15. Como não existe um algarismo "15", usamos letras para representar algarismos de "10" a "15", no caso, "A" a "F", maiúsculas ou minúsculas:


int j = 0xAB3400; // base hexadecimal
System.out.println(j); // saída: 11219968
Já na base binária, começamos com 0b, e só podemos usar "0" e "1":


int b = 0b100001011; // base binária
System.out.println(b); // saída: 267
Não é necessário aprender a fazer a conversão entre as diferentes bases e a decimal. Apenas saber quais são os valores possíveis em cada base, para identificar erros de compilação como o que segue:


int i = 0769; // erro, base octal não pode usar 9
Notação científica
Ao declarar doubles ou floats, podemos usar a notação científica:


double d = 3.1E2;
System.out.println(d); // 310.0

float e = 2e3f;
System.out.println(e); // 2000.0

float f = 1E4F;
System.out.println(f); // 10000.0
Usando underlines em literais
A partir do Java 7, existe a possibilidade de usarmos underlines (_) quando estamos declarando literais para facilitar a leitura do código:


int a = 123_456_789;
Existem algumas regras sobre onde esses underlines podem ser posicionados nos literais, e caso sejam colocados em locais errados resultam em erros de compilação. A regra básica é que eles só podem ser posicionados com valores numéricos em ambos os lados. Vamos ver alguns exemplos:


int v1 = 0_100_267_760;        // ok
int v2 = 0_x_4_13;             // erro, _ antes e depois do x
int v3 = 0b_x10_BA_75;         // erro, _ depois do b 
int v4 = 0b_10000_10_11;     // erro, _ depois do b
int v5 = 0xa10_AF_75;         // ok, apesar de ser letra 
                            // representa dígito
int v6 = _123_341;            // erro, inicia com _
int v7 = 123_432_;            // erro, termina com _
int v8 = 0x1_0A0_11;        // ok
int v9 = 144__21_12;        // ok
A mesma regra se aplica a números de ponto flutuante:


double d1 = 345.45_e3;        // erro, _ antes do e
double d2 = 345.45e_3;        // erro, _ depois do e
double d3 = 345.4_5e3;        // ok
double d4 = 34_5.45e3_2;    // ok
double d5 = 3_4_5.4_5e3;    // ok
double d6 = 345._45F;        // erro, _ depois do .
double d7 = 345_.45;        // erro, _ antes do .
double d8 = 345.45_F;        // erro, _ antes do indicador de 
                            // float
double d9 = 345.45_d;        // erro, _ antes do indicador de 
                            // double
Iniciando chars
Os chars são iniciados colocando o caractere desejado entre aspas simples:


char c = 'A';
Mas podemos iniciar com números também. Neste caso, o número representa a posição do caractere na tabela unicode:


char c = 65;
System.out.println(c); // imprime A
Não é necessário decorar a tabela unicode, mas é preciso prestar atenção a pegadinhas como a seguinte:


char sete = 7; // número, pois não está entre aspas simples
System.out.println(sete);  // Não imprime nada!!!!
Quando usando programas em outras línguas, às vezes queremos usar caracteres unicode, mas não temos um teclado com tais teclas (árabe, chinês etc.). Neste caso, podemos usar uma representação literal de um caractere unicode em nosso código, iniciando o char com \u :


char c = '\u03A9'; // unicode
System.out.println(c); // imprime a letra grega ômega
Identificadores
Quando escrevemos nossos programas, usamos basicamente dois tipos de termos para compor nosso código: identificadores e palavras reservadas.

Chamamos de identificadores as palavras definidas pelo programador para nomear variáveis, métodos, construtores, classes, interfaces etc.

Já palavras reservadas ou palavras-chave são termos predefinidos da linguagem que podemos usar para definir comandos (if, for, class, entre outras).

São diversas palavras-chave na linguagem java:

abstract
assert
boolean
break
byte
case
catch
char
class
const
continue
default
do
double
else
enum
extends
false
final
finally
float
for
goto
if
implements
import
instanceof
int
interface
long
native
new
null
package
private
protected
public
return
short
static
strictfp
super
switch
synchronized
this
throw
throws
transient
true
try
void
volatile
while
null, false e true
Outras três palavras reservadas que não aparecem nessa lista são true, false e null. Mas, segundo a especificação na linguagem Java, esses três termos são considerados literais e não palavras-chave (embora também sejam reservadas), totalizando 53 palavras reservadas.

http://java.sun.com/docs/books/tutorial/java/nutsandbolts/_keywords.html

Identificadores válidos devem seguir as seguintes regras:

Não podem ser igual a uma palavra-chave;
Podem usar letras (unicode), números, $ e _;
O primeiro caractere não pode ser um número;
Podem possuir qualquer número de caracteres.
Os identificadores são case sensitive, ou seja, respeitam maiúsculas e minúsculas:


int umNome; // ok
int umnome;    // ok, diferente do anterior
int _num;    // ok
int $_ab_c; // ok
int x_y;    // ok
int false;    // inválido, palavra reservada
int x-y;     // inválido, traço
int 4num;     // inválido, começa com número
int av#f;     // inválido, #
int num.spc; // inválido, ponto no meio
TIRAR DÚVIDA

#Differentiate between object reference variables and primitive variables

 Diferenciar entre variáveis de referências a objetos e tipos primitivos
PRÓXIMA ATIVIDADE

As variáveis de tipos primitivos de fato armazenam os valores (e não ponteiros/referências). Ao se atribuir o valor de uma variável primitiva a uma outra variável, o valor é copiado, e o original não é alterado:


int a = 10;
int b = a; // copiando o valor de a para b
b++; // somando 1 em b
System.out.println(a); // continua com 10.
Os programas construídos com o modelo orientado a objetos utilizam, evidentemente, objetos. Para acessar um atributo ou invocar um método de qualquer objeto, é necessário que tenhamos armazenada uma referência para o mesmo.

Uma variável de referência é um ponteiro para o endereço de memória onde o objeto se encontra. Ao atribuirmos uma variável de referência a outra, estamos copiando a referência, ou seja, fazendo com que as duas variáveis apontem para o mesmo objeto, e não criando um novo objeto:


class Objeto {
    int valor;
}

class Teste{
    public static void main(String[] args){
        Objeto a = new Objeto();
        Objeto b = a; // agora b aponta para o mesmo objeto de a

        a.valor = 5;

        System.out.println(b.valor); // imprime 5
    }
}
Duas referências são consideradas iguais somente se elas estão apontando para o mesmo objeto. Mesmo que os objetos que elas apontem sejam iguais, ainda são referências para objetos diferentes:


Objeto a = new Objeto();
a.valor = 5;

Objeto b = new Objeto();
b.valor = 5;

Objeto c = a;

System.out.println(a == b); // false
System.out.println(a == c); // true
Veremos bastante sobre comparação de tipos primitivos e de referências mais à frente.

TIRAR DÚVIDA
#Know how to read or write to object fields
 Lendo ou escrevendo campos de objetos
PRÓXIMA ATIVIDADE

Ler e escrever propriedades em objetos é uma das tarefas mais comuns em um programa java. Para acessar um atributo, usamos o operador . (ponto), junto a uma variável de referência para um objeto. Veja a seguinte classe:



class Carro {
    String modelo;
    int ano;

    public Carro() { ano = 2014; }

    public String getDadosDeImpressao() {
        return modelo + " - " + ano;
    }

    public void setModelo(String m) {
        this.modelo = m;
    }
}
Vamos escrever um código para usar essa classe:


Carro a = new Carro();
a.modelo = "Palio";     // acessando diretamente o atributo
a.setModelo("Palio");    // acessando o atributo por um método

// acessando o método e passando o retorno como argumento para
// o método println
System.out.println(a.getDadosDeImpressao());  

}
As linhas 2 e 3 têm exatamente o mesmo efeito. Como iniciamos o valor da propriedade ano no construtor, ao chamar o método imprimeDados, o valor 2014 é exibido junto ao nome do modelo.

Quando estamos dentro da classe, não precisamos de nenhum operador para acessar os atributos de instância da classe. Opcionalmente, podemos usar a palavra-chave this, que serve como uma variável de referência para o próprio objeto onde o código está sendo executado:


class Carro{
    int ano;
    int modelo;

    public Carro(){ 
        modelo = "Indefinido";    // acessando variável de 
                                // instancia sem o this
        this.ano = 2014;        // acessando com o this.
    }
TIRAR DÚVIDA

#Explain an Object's Lifecycle (creation, "dereference by reassignment" and garbage collection)

 O ciclo de vida de um objeto
PRÓXIMA ATIVIDADE

O ciclo de vida dos objetos java está dividido em três fases distintas. Vamos conhecê-las e entender o que cada uma significa.

Criação de objetos
Toda vez que usamos o operador new, estamos criando uma nova instância de um objeto na memória:


class Pessoa {
    String nome;
}

class Teste {
    public static void main(String[] args) {
        Pessoa p = new Pessoa(); // criando um novo objeto do 
                                 // tipo Pessoa
    }
}
Repare que há uma grande diferença entre criar um objeto e declarar uma variável. A variável é apenas uma referência, um ponteiro, não contém um objeto de verdade.


// Apenas declarando a variável, 
// nenhum objeto foi criado aqui
Pessoa p;

// Agora um objeto foi criado e atribuído a variável
p = new Pessoa();
Objeto acessível
A partir do momento em que um objeto foi criado e atribuído a uma variável, dizemos que o objeto está acessível, ou seja, podemos usá-lo em nosso programa:


Pessoa p = new Pessoa(); // criação
p.nome = "Mário"; // acessando e usando o objeto
Objeto inacessível
Um objeto é acessível enquanto for possível "alcançá-lo" através de alguma referência direta ou indireta. Caso não exista nenhum caminho direto ou indireto para acessar esse objeto, ele se torna inacessível.:


Pessoa p = new Pessoa();
p.nome = "Mário";

// atribuímos a p o valor null
// o objeto não está mais acessível
p = null

// criando um objeto sem variável
new Pessoa();
Nesse código, criamos um objeto do tipo Pessoa e o atribuímos à variável p. Na linha 6 atribuímos null a p. O que acontece com o objeto anterior? Ele simplesmente não pode mais ser acessado por nosso programa, pois não temos nenhum ponteiro para ele. O mesmo pode ser dito do objeto criado na linha 9. Após essa linha, não conseguimos mais acessar esse objeto.

Outra maneira de ter um objeto inacessível é quando o escopo da variável que aponta para ele termina:


int valor = 100;
if( valor > 50) {
    Pessoa p = new Pessoa();
    p.nome = "João";
} // Após esta linha, o objeto do tipo Pessoa não está mais 
  // acessível
Garbage Collector
Todo objeto inacessível é considerado elegível para o ::garbage collector::. Algumas questões da prova perguntam quantos objetos são elegíveis ao garbage collector ao final de algum trecho de código:


public class Bla {
     int b;
     public static void main(String[] args) {
         Bla b;
        for (int i = 0; i < 10; i++) {
             b = new Bla(); 
             b.b = 10;
         }
           System.out.println("fim");
     }
 }
Ao chegar na linha 9, temos 9 objetos elegíveis para o Garbage Collector.

Objetos elegíveis X Objetos coletados
O ::garbage collector:: roda em segundo plano juntamente com sua aplicação java. Não é possível prever quando ele será executado, portanto não se pode dizer com certeza quantos objetos foram efetivamente coletados em um certo ponto da aplicação. O que podemos determinar é quantos objetos são elegíveis para a coleta. A prova pode tentar se aproveitar do descuido do desenvolvedor aqui: nunca temos certeza de quantos objetos passaram pelo garbage collector, logo, somente indique quantos estão passíveis de serem coletados.

Por fim, é importante ver um exemplo de referência indireta, no qual nenhum objeto pode ser "garbage coletado":


import java.util.*;
class Carro {

}
class Carros {
    List<Carro> carros = new ArrayList<Carro>();
}
class Teste {
    public static void main(String args[]) {
        Carros carros = new Carros();
        for(int i = 0; i < 100; i++)
            carros.carros.add(new Carro());
        // até essa linha todos ainda podem ser alcançados
    }
}
Nesse código, por mais que tenhamos criados 100 carros e um objeto do tipo Carros, nenhum deles pode ser garbage coletado pois todos podem ser alcançados direta ou indiretamente através de nossa thread principal.

TIRAR DÚVIDA

#Develop code that uses wrapper classes such as Boolean, Double, and Integer

 Desenvolver código que usa classes wrappers como Boolean, Double e Integer
PRÓXIMA ATIVIDADE

Java 8 - Trabalhando com tipos de dados em Java
Desenvolver código que usa classes wrappers como Boolean, Double e Integer
::Wrappers:: são classes de objetos que representam tipos primitivos. Existe um ::wrapper:: para cada primitivo, conforme a lista a seguir:

boolean : Boolean
byte : Byte
short : Short
char : Character
int : Integer
long : Long
float : Float
double : Double
Criando ::wrappers::
Todos os ::wrappers:: numéricos possuem dois construtores, um que recebe o tipo primitivo, e um que recebe String. O construtor que recebe String pode lançar NumberFormatException, se a String fornecida não puder ser convertida ao tipo em questão:


Double d1 = new Double(22.5);  
Double d2 = new Double("22.5");
Double d2 = new Double("abc"); //throws NumberFormatException
A classe Character possui apenas um construtor, que recebe um char como argumento:


Character c = new Character('d');
A classe Boolean também possui dois construtores, um que recebe boolean e outro que recebe String. Caso a String passada como argumento tenha o valor "true", com maiúsculas ou minúsculas, o resultado será true; qualquer outro valor resultará em false:


Boolean b1 = new Boolean(true);   // true
Boolean b2 = new Boolean("true"); // true
Boolean b3 = new Boolean("TrUe"); // true
Boolean b4 = new Boolean("T");    // false
Convertendo de ::wrappers:: para primitivos
Para converter um ::wrapper:: em um primitivo, existem vários métodos no formato xxxValue(), onde xxx é o tipo para o qual gostaríamos de realizar a conversão:


Long l = new Long("123");

byte b = l.byteValue();
double d = l.doubleValue();
int i = l.intValue();
short s = l.shortValue();
Todos os tipos numéricos podem ser convertidos entre si. Os tipos Boolean e Character só possuem método para converter para o próprio tipo primitivo:


boolean b = new Boolean("true").booleanValue();
char c = new Character('z').charValue();
Convertendo de String para ::wrappers:: ou primitivos
Além dos construtores dos ::wrappers:: que recebem String como parâmetro, também existem métodos para realizar transformações entre ::strings::, ::wrappers:: e primitivos.

Vamos começar convertendo de ::strings:: para primitivos. Cada ::wrapper:: possui um método no formato parseXXX onde XXX é o tipo do ::wrapper::. Este método também lança NumberFormatException caso não consiga fazer a conversão:


double d = Double.parseDouble("23.4");
long l = Long.parseLong("23");
int i = Integer.parseInt("444");
Os ::wrappers:: de números inteiros possuem uma variação do parseXXX que recebe como segundo argumento a base a ser usada na conversão:


short i1 = Short.parseShort("11",10); // 11  Decimal
int i2 = Integer.parseInt("11",16);   // 17  HexaDecimal
byte i3 = Byte.parseByte("11",8);     // 9   Octal
int i4 = Integer.parseInt("11",2);    // 3   Binary
int i5 = Integer.parseInt("A",16);    // 10  HexaDecimal
int i6 = Integer.parseInt("FF",16);   // 255 HexaDecimal
Já para converter uma String diretamente para um ::wrapper:: podemos ou usar o construtor como vimos anteriormente, ou usar o método valueOf, disponível em todos os ::wrappers::. A assinatura destes métodos é idêntica à do parseXXX, inclusive com versões que recebem a base de conversão para tipo inteiros:


Double d = Double.valueOf("23.4");
Long l = Long.valueOf("23");
Integer i1 = Integer.valueOf("444");        
Integer i2 = Integer.valueOf("5AF", 16);
Convertendo de primitivos ou ::wrappers:: para String
Assim como todo objeto Java, os ::wrappers:: também possuem um método toString:


Integer i = Integer.valueOf(256);
String number = i.toString();
Além do toString padrão, há uma versão estática sobrecarregada, que recebe o tipo primitivo como argumento. Ademais, os tipos Long e Integer possuem uma versão que, além do primitivo, também recebem a base:


String d = Double.toString(23.5);
String s = Short.toString((short)23);
String i = Integer.toString(23);
String l = Long.toString(20, 16);
Além destes, as classes Long e Integer ainda possuem outros métodos para fazer a conversão direta para a base escolhida:


String binaryString = Integer.toBinaryString(8); //1000, binary
String hexString = Long.toHexString(11);       // B, Hexadecimal
String octalString = Integer.toOctalString(22);  // 26 Octal
Autoboxing
Até o Java 1.4 não era possível executar operações em cima de ::wrappers::. Por exemplo, para somar 1 em um Integer era necessário o seguinte código:


Integer intWrapper = Integer.valueOf(1);
int intPrimitive = intWrapper.intValue();
intPrimitive++;
intWrapper = Integer.valueOf(intPrimitive);
A partir do Java 5, foi incluído um recurso chamado autoboxing. O próprio compilador é responsável por transformar os ::wrappers:: em primitivos (::unboxing::) e primitivos em ::wrappers:: (::boxing::). A mesma operação de somar 1 em um Integer agora é:


Integer intWrapper = Integer.valueOf(1);
intWrapper++; //will unbox, increment, then box again.
Repara que não há magia. A única diferença é que, em vez de você mesmo escrever o código que faz o ::boxing:: e ::unboxing::, agora esse código é gerado pelo compilador.

Comparando ::wrappers::
Veja o seguinte código:


Integer i1 = 1234;
Integer i2 = 1234;
System.out.println(i1 == i2);      //false
System.out.println(i1.equals(i2)); //true
Apesar de parecer que estamos trabalhando com primitivos, estamos usando objetos aqui, logo, quando esses objetos são comparados usando == o resultado é false, já que são duas instâncias diferentes de Integer.

Agora veja o seguinte código:


Integer i1 = 123;
Integer i2 = 123;
System.out.println(i1 == i2);      //true
System.out.println(i1.equals(i2)); //true
Repare que o resultado do == foi true, mas o que aconteceu? É que o Java, para economizar memória, mantém um cache de alguns objetos, e toda vez que é feito um ::boxing:: ele os reutiliza. Os seguintes objetos são mantidos no cache:

Todos Boolean e Byte;
Short e Integer de -128 até 127;
Caracter ASCII, como letras, números etc.
Sempre que você encontrar comparações usando == envolvendo ::wrappers::, preste muita atenção aos valores: se forem baixos, é possível que o resultado seja true mesmo sendo objetos diferentes!

NullPointerException em operações envolvendo ::wrappers::
Fique atento, pois, como ::wrappers:: são objetos, eles podem assumir o valor de null. Qualquer operação executada envolvendo um objeto null resultará em um NullPointerException:


Integer a = null;
int b = 44;
System.out.println(a + b); //throws NPE
TIRAR DÚVIDA

#Chamadas de métodos nos objetos
 Chamadas de métodos nos objetos
PRÓXIMA ATIVIDADE

Além de acessar atributos, também podemos invocar métodos em um objeto. Para isso usamos o operador . (ponto), junto a uma variável de referência para um objeto. Deve-se prestar atenção ao número e tipo de parâmetros do método, além do seu retorno. Métodos declarados como void não possuem retorno, logo, não podem ser atribuídos a nenhuma variável ou passado para outro método como parâmetro:



class Pessoa{

    String nome;

    public String getNome(){
        return nome;
    }

    public void setNome(String nome){
        this.nome = nome;
    }
}

class Teste{
    public static void main(String[] args){
        Pessoa p = new Pessoa();

        //chamando método na variável de ref.
        p.setNome("Mario");

        //Atribuindo o retorno do método a variável.
        String nome = p.getNome();

        // erro, método é void
        String a = p.setNome("X");
    }
}
Quando um método está sendo invocado em um objeto, podemos chamar outro método no mesmo objeto através da invocação direta ao nome do método:


class A {
    void metodo1() {
        metodo2(); // chama o metodo2 no objeto onde metodo1 foi
                   // chamado
    }
    void metodo2() {
    }
}
Argumentos variáveis: varargs
A partir do Java 5, varargs possibilitam um método que receba um número variável (não fixo) de parâmetros. É a maneira de receber um array de objetos e possibilitar uma chamada mais fácil do método.

Um caso especial é quando método recebe um argumento variável (varargs). Neste caso, podemos chamá-lo com qualquer número de argumentos:



class Calculadora{
    public int soma(int... nums){
        int total = 0;
        for (int a : nums){
            total+= a;
        }
        return total;
    }

}
nums realmente é um array aqui, você pode fazer um for usando o length, ou mesmo usar o enhanced for. A invocação desse método pode ser feita de várias maneiras:


    public static void main (String[] args){
        Calculadora c = new Calculadora();    

        //Todas as chamadas abaixo sao válidas
        System.out.println(c.soma());
        System.out.println(c.soma(1));
        System.out.println(c.soma(1,2));
        System.out.println(c.soma(1,2,3,4,5,6,7,8,9));
    }
Em todos os casos, um array será criado, nunca null será passado. Um parâmetro varargs deve ser sempre o último da assinatura do método para evitar ambiguidade. Isso implica que apenas um dos parâmetros de um método seja varargs. E repare que os argumentos variáveis têm que ser do mesmo tipo.

E será dada a prioridade para o método que já podia existir antes no Java 1.4:


void metodo(int ... x) { }
void metodo(int x) {}

metodo(5);
Isso vai invocar o segundo método. Podemos também passar um array de ints para um método que recebe um varargs:


void metodo(int ... x) { }

metodo(new int[] {1,2,3,4});
Mas nunca podemos chamar um método que recebe array como se ele fosse varargs:


void metodo(int[] x) { }

metodo(1,2,3); // não compila
TIRAR DÚVIDA
